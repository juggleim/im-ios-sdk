// Generated by the protocol buffer compiler.  DO NOT EDIT!
// clang-format off
// source: appmessages.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30007
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30007 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

#import <stdatomic.h>

#import "Appmessages.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective-C Class declarations
// Forward declarations of Objective-C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(AddGrpAssistantReq);
GPBObjCClassDeclaration(AddHisMsgReq);
GPBObjCClassDeclaration(AssistantMsgResp);
GPBObjCClassDeclaration(BanUser);
GPBObjCClassDeclaration(BanUsersReq);
GPBObjCClassDeclaration(BlockUser);
GPBObjCClassDeclaration(BlockUsersReq);
GPBObjCClassDeclaration(ChatAttItem);
GPBObjCClassDeclaration(ChatAttReq);
GPBObjCClassDeclaration(ChatAtts);
GPBObjCClassDeclaration(ChatMembersDispatchReq);
GPBObjCClassDeclaration(ChatRoomReq);
GPBObjCClassDeclaration(CheckGroupMembersReq);
GPBObjCClassDeclaration(CheckGroupMembersResp);
GPBObjCClassDeclaration(CleanHisMsgReq);
GPBObjCClassDeclaration(ClearUnreadReq);
GPBObjCClassDeclaration(Conversation);
GPBObjCClassDeclaration(ConversationsReq);
GPBObjCClassDeclaration(DelHisMsgsReq);
GPBObjCClassDeclaration(DestroyHisMsgReq);
GPBObjCClassDeclaration(DownMsg);
GPBObjCClassDeclaration(DownMsgSet);
GPBObjCClassDeclaration(GlobalConver);
GPBObjCClassDeclaration(GroupIdsReq);
GPBObjCClassDeclaration(GroupInfo);
GPBObjCClassDeclaration(GroupInfoReq);
GPBObjCClassDeclaration(GroupInfosResp);
GPBObjCClassDeclaration(GroupMember);
GPBObjCClassDeclaration(GroupMemberMuteReq);
GPBObjCClassDeclaration(GroupMembersReq);
GPBObjCClassDeclaration(GroupMembersResp);
GPBObjCClassDeclaration(GroupMuteReq);
GPBObjCClassDeclaration(GroupSnapshot);
GPBObjCClassDeclaration(IndexScope);
GPBObjCClassDeclaration(KickUserReq);
GPBObjCClassDeclaration(KvItem);
GPBObjCClassDeclaration(MarkGrpMsgReadReq);
GPBObjCClassDeclaration(MarkReadReq);
GPBObjCClassDeclaration(MemberReadDetailItem);
GPBObjCClassDeclaration(MentionInfo);
GPBObjCClassDeclaration(MentionInfos);
GPBObjCClassDeclaration(MentionMsg);
GPBObjCClassDeclaration(MergeMsgReq);
GPBObjCClassDeclaration(MergedMsgs);
GPBObjCClassDeclaration(ModifyMsgReq);
GPBObjCClassDeclaration(MsgExtItem);
GPBObjCClassDeclaration(Notify);
GPBObjCClassDeclaration(OnlineOfflineMsg);
GPBObjCClassDeclaration(OnlineStatus);
GPBObjCClassDeclaration(PushData);
GPBObjCClassDeclaration(QiniuCredResp);
GPBObjCClassDeclaration(QryBanUsersReq);
GPBObjCClassDeclaration(QryBanUsersResp);
GPBObjCClassDeclaration(QryBlockUsersReq);
GPBObjCClassDeclaration(QryBlockUsersResp);
GPBObjCClassDeclaration(QryConverReq);
GPBObjCClassDeclaration(QryConverResp);
GPBObjCClassDeclaration(QryConversationsReq);
GPBObjCClassDeclaration(QryConversationsResp);
GPBObjCClassDeclaration(QryFileCredReq);
GPBObjCClassDeclaration(QryFileCredResp);
GPBObjCClassDeclaration(QryGlobalConversReq);
GPBObjCClassDeclaration(QryGlobalConversResp);
GPBObjCClassDeclaration(QryGroupMembersReq);
GPBObjCClassDeclaration(QryGrpSnapshotReq);
GPBObjCClassDeclaration(QryHisMsgByIdsReq);
GPBObjCClassDeclaration(QryHisMsgsReq);
GPBObjCClassDeclaration(QryMentionMsgsReq);
GPBObjCClassDeclaration(QryMentionMsgsResp);
GPBObjCClassDeclaration(QryMergedMsgsReq);
GPBObjCClassDeclaration(QryMsgLatestIndexReq);
GPBObjCClassDeclaration(QryMsgLatestIndexResp);
GPBObjCClassDeclaration(QryReadDetailReq);
GPBObjCClassDeclaration(QryReadDetailResp);
GPBObjCClassDeclaration(QryReadInfosReq);
GPBObjCClassDeclaration(QryReadInfosResp);
GPBObjCClassDeclaration(QryTopConversReq);
GPBObjCClassDeclaration(QryTotalUnreadCountReq);
GPBObjCClassDeclaration(QryTotalUnreadCountResp);
GPBObjCClassDeclaration(ReadInfoItem);
GPBObjCClassDeclaration(RecallMsgReq);
GPBObjCClassDeclaration(RpcMessageWraper);
GPBObjCClassDeclaration(SimpleConversation);
GPBObjCClassDeclaration(SimpleMsg);
GPBObjCClassDeclaration(SyncChatroomReq);
GPBObjCClassDeclaration(SyncChatroomResp);
GPBObjCClassDeclaration(SyncConversationsReq);
GPBObjCClassDeclaration(SyncMsgReq);
GPBObjCClassDeclaration(TopConversResp);
GPBObjCClassDeclaration(UndisturbConverItem);
GPBObjCClassDeclaration(UndisturbConversReq);
GPBObjCClassDeclaration(UpMsg);
GPBObjCClassDeclaration(UserIdReq);
GPBObjCClassDeclaration(UserIdsReq);
GPBObjCClassDeclaration(UserInfo);
GPBObjCClassDeclaration(UserInfosResp);
GPBObjCClassDeclaration(UserOnlineItem);
GPBObjCClassDeclaration(UserOnlineStatusReq);
GPBObjCClassDeclaration(UserOnlineStatusResp);
GPBObjCClassDeclaration(UserRegResp);

#pragma mark - AppmessagesRoot

@implementation AppmessagesRoot

// No extensions in the file and no imports or none of the imports (direct or
// indirect) defined extensions, so no need to generate +extensionRegistry.

@end

static GPBFileDescription AppmessagesRoot_FileDescription = {
  .package = NULL,
  .prefix = NULL,
  .syntax = GPBFileSyntaxProto3
};

#pragma mark - Enum RpcMsgType

GPBEnumDescriptor *RpcMsgType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "UserPub\000UserPubAck\000ServerPub\000ServerPubAc"
        "k\000QueryMsg\000QueryAck\000QueryConfirm\000";
    static const int32_t values[] = {
        RpcMsgType_UserPub,
        RpcMsgType_UserPubAck,
        RpcMsgType_ServerPub,
        RpcMsgType_ServerPubAck,
        RpcMsgType_QueryMsg,
        RpcMsgType_QueryAck,
        RpcMsgType_QueryConfirm,
    };
    static const char *extraTextFormatInfo = "\007\000\007\000\001\n\000\002\t\000\003\014\000\004\010\000\005\010\000\006\014\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RpcMsgType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RpcMsgType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RpcMsgType_IsValidValue(int32_t value__) {
  switch (value__) {
    case RpcMsgType_UserPub:
    case RpcMsgType_UserPubAck:
    case RpcMsgType_ServerPub:
    case RpcMsgType_ServerPubAck:
    case RpcMsgType_QueryMsg:
    case RpcMsgType_QueryAck:
    case RpcMsgType_QueryConfirm:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MentionType

GPBEnumDescriptor *MentionType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "MentionDefault\000MentionAll\000MentionSomeone"
        "\000MentionAllAndSomeone\000";
    static const int32_t values[] = {
        MentionType_MentionDefault,
        MentionType_MentionAll,
        MentionType_MentionSomeone,
        MentionType_MentionAllAndSomeone,
    };
    static const char *extraTextFormatInfo = "\004\000\016\000\001\n\000\002\016\000\003\024\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MentionType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MentionType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MentionType_IsValidValue(int32_t value__) {
  switch (value__) {
    case MentionType_MentionDefault:
    case MentionType_MentionAll:
    case MentionType_MentionSomeone:
    case MentionType_MentionAllAndSomeone:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ChannelType

GPBEnumDescriptor *ChannelType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "Unknown\000Private\000Group\000Chatroom\000System\000As"
        "sistant\000";
    static const int32_t values[] = {
        ChannelType_Unknown,
        ChannelType_Private,
        ChannelType_Group,
        ChannelType_Chatroom,
        ChannelType_System,
        ChannelType_Assistant,
    };
    static const char *extraTextFormatInfo = "\006\000\007\000\001\007\000\002\005\000\003\010\000\004\006\000\005\t\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChannelType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChannelType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChannelType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChannelType_Unknown:
    case ChannelType_Private:
    case ChannelType_Group:
    case ChannelType_Chatroom:
    case ChannelType_System:
    case ChannelType_Assistant:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum NotifyType

GPBEnumDescriptor *NotifyType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "Default\000Msg\000ChatroomMsg\000";
    static const int32_t values[] = {
        NotifyType_Default,
        NotifyType_Msg,
        NotifyType_ChatroomMsg,
    };
    static const char *extraTextFormatInfo = "\003\000\007\000\001\003\000\002\013\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(NotifyType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:NotifyType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL NotifyType_IsValidValue(int32_t value__) {
  switch (value__) {
    case NotifyType_Default:
    case NotifyType_Msg:
    case NotifyType_ChatroomMsg:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum BanType

GPBEnumDescriptor *BanType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "Permanent\000Temporary\000";
    static const int32_t values[] = {
        BanType_Permanent,
        BanType_Temporary,
    };
    static const char *extraTextFormatInfo = "\002\000\t\000\001\t\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(BanType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:BanType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL BanType_IsValidValue(int32_t value__) {
  switch (value__) {
    case BanType_Permanent:
    case BanType_Temporary:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum OnlineType

GPBEnumDescriptor *OnlineType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "Offline\000Online\000";
    static const int32_t values[] = {
        OnlineType_Offline,
        OnlineType_Online,
    };
    static const char *extraTextFormatInfo = "\002\000\007\000\001\006\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(OnlineType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:OnlineType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL OnlineType_IsValidValue(int32_t value__) {
  switch (value__) {
    case OnlineType_Offline:
    case OnlineType_Online:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ChatMembersDispatchType

GPBEnumDescriptor *ChatMembersDispatchType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "DispatchDefault\000JoinChatroom\000QuitChatroo"
        "m\000";
    static const int32_t values[] = {
        ChatMembersDispatchType_DispatchDefault,
        ChatMembersDispatchType_JoinChatroom,
        ChatMembersDispatchType_QuitChatroom,
    };
    static const char *extraTextFormatInfo = "\003\000\017\000\001\014\000\002\014\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChatMembersDispatchType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChatMembersDispatchType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChatMembersDispatchType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChatMembersDispatchType_DispatchDefault:
    case ChatMembersDispatchType_JoinChatroom:
    case ChatMembersDispatchType_QuitChatroom:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ChatAttOptType

GPBEnumDescriptor *ChatAttOptType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "ChatAttOptDefault\000ChatAttOptAdd\000ChatAttO"
        "ptDel\000";
    static const int32_t values[] = {
        ChatAttOptType_ChatAttOptDefault,
        ChatAttOptType_ChatAttOptAdd,
        ChatAttOptType_ChatAttOptDel,
    };
    static const char *extraTextFormatInfo = "\003\000\n\207\000\001\n\203\000\002\n\203\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChatAttOptType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChatAttOptType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChatAttOptType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChatAttOptType_ChatAttOptDefault:
    case ChatAttOptType_ChatAttOptAdd:
    case ChatAttOptType_ChatAttOptDel:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum FileType

GPBEnumDescriptor *FileType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "DefaultFileType\000Image\000Audio\000Video\000File\000";
    static const int32_t values[] = {
        FileType_DefaultFileType,
        FileType_Image,
        FileType_Audio,
        FileType_Video,
        FileType_File,
    };
    static const char *extraTextFormatInfo = "\005\000\017\000\001\005\000\002\005\000\003\005\000\004\004\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(FileType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:FileType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL FileType_IsValidValue(int32_t value__) {
  switch (value__) {
    case FileType_DefaultFileType:
    case FileType_Image:
    case FileType_Audio:
    case FileType_Video:
    case FileType_File:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum OssType

GPBEnumDescriptor *OssType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "DefaultOss\000Qiniu\000";
    static const int32_t values[] = {
        OssType_DefaultOss,
        OssType_Qiniu,
    };
    static const char *extraTextFormatInfo = "\002\000\n\000\001\005\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(OssType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:OssType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL OssType_IsValidValue(int32_t value__) {
  switch (value__) {
    case OssType_DefaultOss:
    case OssType_Qiniu:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RpcMessageWraper

@implementation RpcMessageWraper

@dynamic rpcMsgType;
@dynamic appKey;
@dynamic session;
@dynamic method;
@dynamic targetId;
@dynamic sourceMethod;
@dynamic requesterId;
@dynamic qos;
@dynamic reqIndex;
@dynamic publishType;
@dynamic isFromApi;
@dynamic extParams, extParams_Count;
@dynamic terminalNum;
@dynamic noSendbox;
@dynamic resultCode;
@dynamic msgSendTime;
@dynamic msgId;
@dynamic msgSeqNo;
@dynamic groupId;
@dynamic targetIdsArray, targetIdsArray_Count;
@dynamic appDataBytes;
@dynamic hasSenderInfo, senderInfo;

typedef struct RpcMessageWraper__storage_ {
  uint32_t _has_storage_[1];
  RpcMsgType rpcMsgType;
  int32_t qos;
  int32_t reqIndex;
  int32_t publishType;
  int32_t terminalNum;
  int32_t resultCode;
  NSString *appKey;
  NSString *session;
  NSString *method;
  NSString *targetId;
  NSString *sourceMethod;
  NSString *requesterId;
  NSMutableDictionary *extParams;
  NSString *msgId;
  NSString *groupId;
  NSMutableArray *targetIdsArray;
  NSData *appDataBytes;
  UserInfo *senderInfo;
  int64_t msgSendTime;
  int64_t msgSeqNo;
} RpcMessageWraper__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rpcMsgType",
        .dataTypeSpecific.enumDescFunc = RpcMsgType_EnumDescriptor,
        .number = RpcMessageWraper_FieldNumber_RpcMsgType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, rpcMsgType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "appKey",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_AppKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, appKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "session",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_Session,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, session),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "method",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_Method,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, method),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_TargetId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sourceMethod",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_SourceMethod,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, sourceMethod),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "requesterId",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_RequesterId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, requesterId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "qos",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_Qos,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, qos),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "reqIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_ReqIndex,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, reqIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "publishType",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_PublishType,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, publishType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isFromApi",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_IsFromApi,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "extParams",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_ExtParams,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, extParams),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "terminalNum",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_TerminalNum,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, terminalNum),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "noSendbox",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_NoSendbox,
        .hasIndex = 13,
        .offset = 14,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "resultCode",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_ResultCode,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, resultCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "msgSendTime",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_MsgSendTime,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, msgSendTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_MsgId,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgSeqNo",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_MsgSeqNo,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, msgSeqNo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_GroupId,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_TargetIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, targetIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "appDataBytes",
        .dataTypeSpecific.clazz = Nil,
        .number = RpcMessageWraper_FieldNumber_AppDataBytes,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, appDataBytes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "senderInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(UserInfo),
        .number = RpcMessageWraper_FieldNumber_SenderInfo,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(RpcMessageWraper__storage_, senderInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(RpcMessageWraper)
                                   messageName:@"RpcMessageWraper"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RpcMessageWraper__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\023\001\n\000\002\006\000\005\010\000\006\014\000\007\013\000\t\010\000\n\013\000\013\t\000\014\t\000\r\013\000\016\t\000\025\n\000\026\013\000"
        "\027\005\000\030\010\000\037\007\000 \000targetIds\0002\014\0003\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RpcMessageWraper_RpcMsgType_RawValue(RpcMessageWraper *message) {
  GPBDescriptor *descriptor = [RpcMessageWraper descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RpcMessageWraper_FieldNumber_RpcMsgType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetRpcMessageWraper_RpcMsgType_RawValue(RpcMessageWraper *message, int32_t value) {
  GPBDescriptor *descriptor = [RpcMessageWraper descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RpcMessageWraper_FieldNumber_RpcMsgType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - UpMsg

@implementation UpMsg

@dynamic msgType;
@dynamic msgContent;
@dynamic flags;
@dynamic clientUid;
@dynamic hasPushData, pushData;
@dynamic hasMentionInfo, mentionInfo;
@dynamic hasReferMsg, referMsg;
@dynamic toUserIdsArray, toUserIdsArray_Count;
@dynamic hasMergedMsgs, mergedMsgs;

typedef struct UpMsg__storage_ {
  uint32_t _has_storage_[1];
  int32_t flags;
  NSString *msgType;
  NSData *msgContent;
  NSString *clientUid;
  PushData *pushData;
  MentionInfo *mentionInfo;
  DownMsg *referMsg;
  NSMutableArray *toUserIdsArray;
  MergedMsgs *mergedMsgs;
} UpMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgType",
        .dataTypeSpecific.clazz = Nil,
        .number = UpMsg_FieldNumber_MsgType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpMsg__storage_, msgType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgContent",
        .dataTypeSpecific.clazz = Nil,
        .number = UpMsg_FieldNumber_MsgContent,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpMsg__storage_, msgContent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "flags",
        .dataTypeSpecific.clazz = Nil,
        .number = UpMsg_FieldNumber_Flags,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpMsg__storage_, flags),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "clientUid",
        .dataTypeSpecific.clazz = Nil,
        .number = UpMsg_FieldNumber_ClientUid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpMsg__storage_, clientUid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushData",
        .dataTypeSpecific.clazz = GPBObjCClass(PushData),
        .number = UpMsg_FieldNumber_PushData,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UpMsg__storage_, pushData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mentionInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(MentionInfo),
        .number = UpMsg_FieldNumber_MentionInfo,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UpMsg__storage_, mentionInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "referMsg",
        .dataTypeSpecific.clazz = GPBObjCClass(DownMsg),
        .number = UpMsg_FieldNumber_ReferMsg,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(UpMsg__storage_, referMsg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "toUserIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = UpMsg_FieldNumber_ToUserIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UpMsg__storage_, toUserIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mergedMsgs",
        .dataTypeSpecific.clazz = GPBObjCClass(MergedMsgs),
        .number = UpMsg_FieldNumber_MergedMsgs,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(UpMsg__storage_, mergedMsgs),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UpMsg)
                                   messageName:@"UpMsg"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpMsg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\010\001\007\000\002\n\000\004\t\000\005\010\000\006\013\000\007\010\000\010\000toUserIds\000\t\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MergedMsgs

@implementation MergedMsgs

@dynamic channelType;
@dynamic userId;
@dynamic targetId;
@dynamic msgsArray, msgsArray_Count;

typedef struct MergedMsgs__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  NSString *userId;
  NSString *targetId;
  NSMutableArray *msgsArray;
} MergedMsgs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = MergedMsgs_FieldNumber_ChannelType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MergedMsgs__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = MergedMsgs_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MergedMsgs__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = MergedMsgs_FieldNumber_TargetId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MergedMsgs__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SimpleMsg),
        .number = MergedMsgs_FieldNumber_MsgsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MergedMsgs__storage_, msgsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MergedMsgs)
                                   messageName:@"MergedMsgs"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MergedMsgs__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\013\000\002\006\000\003\010\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t MergedMsgs_ChannelType_RawValue(MergedMsgs *message) {
  GPBDescriptor *descriptor = [MergedMsgs descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MergedMsgs_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetMergedMsgs_ChannelType_RawValue(MergedMsgs *message, int32_t value) {
  GPBDescriptor *descriptor = [MergedMsgs descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MergedMsgs_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - MentionInfo

@implementation MentionInfo

@dynamic mentionType;
@dynamic targetUsersArray, targetUsersArray_Count;

typedef struct MentionInfo__storage_ {
  uint32_t _has_storage_[1];
  MentionType mentionType;
  NSMutableArray *targetUsersArray;
} MentionInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mentionType",
        .dataTypeSpecific.enumDescFunc = MentionType_EnumDescriptor,
        .number = MentionInfo_FieldNumber_MentionType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MentionInfo__storage_, mentionType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "targetUsersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UserInfo),
        .number = MentionInfo_FieldNumber_TargetUsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MentionInfo__storage_, targetUsersArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MentionInfo)
                                   messageName:@"MentionInfo"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MentionInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\013\000\002\000targetUsers\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t MentionInfo_MentionType_RawValue(MentionInfo *message) {
  GPBDescriptor *descriptor = [MentionInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MentionInfo_FieldNumber_MentionType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetMentionInfo_MentionType_RawValue(MentionInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [MentionInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MentionInfo_FieldNumber_MentionType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - PushData

@implementation PushData

@dynamic title;
@dynamic pushId;
@dynamic pushText;
@dynamic pushExtraData;

typedef struct PushData__storage_ {
  uint32_t _has_storage_[1];
  NSString *title;
  NSString *pushId;
  NSString *pushText;
  NSString *pushExtraData;
} PushData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.clazz = Nil,
        .number = PushData_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PushData__storage_, title),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushId",
        .dataTypeSpecific.clazz = Nil,
        .number = PushData_FieldNumber_PushId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PushData__storage_, pushId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushText",
        .dataTypeSpecific.clazz = Nil,
        .number = PushData_FieldNumber_PushText,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PushData__storage_, pushText),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushExtraData",
        .dataTypeSpecific.clazz = Nil,
        .number = PushData_FieldNumber_PushExtraData,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PushData__storage_, pushExtraData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(PushData)
                                   messageName:@"PushData"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PushData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\002\006\000\003\010\000\004\r\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DownMsg

@implementation DownMsg

@dynamic targetId;
@dynamic channelType;
@dynamic msgType;
@dynamic senderId;
@dynamic msgId;
@dynamic msgSeqNo;
@dynamic msgContent;
@dynamic msgTime;
@dynamic flags;
@dynamic isSend;
@dynamic platform;
@dynamic clientUid;
@dynamic hasPushData, pushData;
@dynamic hasMentionInfo, mentionInfo;
@dynamic isRead;
@dynamic hasReferMsg, referMsg;
@dynamic hasTargetUserInfo, targetUserInfo;
@dynamic hasGroupInfo, groupInfo;
@dynamic hasMergedMsgs, mergedMsgs;
@dynamic undisturbType;
@dynamic memberCount;
@dynamic readCount;
@dynamic unreadIndex;

typedef struct DownMsg__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  int32_t flags;
  int32_t undisturbType;
  int32_t memberCount;
  int32_t readCount;
  NSString *targetId;
  NSString *msgType;
  NSString *senderId;
  NSString *msgId;
  NSData *msgContent;
  NSString *platform;
  NSString *clientUid;
  PushData *pushData;
  MentionInfo *mentionInfo;
  DownMsg *referMsg;
  UserInfo *targetUserInfo;
  GroupInfo *groupInfo;
  MergedMsgs *mergedMsgs;
  int64_t msgSeqNo;
  int64_t msgTime;
  int64_t unreadIndex;
} DownMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsg_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DownMsg__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = DownMsg_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DownMsg__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msgType",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsg_FieldNumber_MsgType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DownMsg__storage_, msgType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "senderId",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsg_FieldNumber_SenderId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DownMsg__storage_, senderId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsg_FieldNumber_MsgId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DownMsg__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgSeqNo",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsg_FieldNumber_MsgSeqNo,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DownMsg__storage_, msgSeqNo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msgContent",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsg_FieldNumber_MsgContent,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DownMsg__storage_, msgContent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "msgTime",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsg_FieldNumber_MsgTime,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DownMsg__storage_, msgTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "flags",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsg_FieldNumber_Flags,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(DownMsg__storage_, flags),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isSend",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsg_FieldNumber_IsSend,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "platform",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsg_FieldNumber_Platform,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(DownMsg__storage_, platform),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clientUid",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsg_FieldNumber_ClientUid,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(DownMsg__storage_, clientUid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushData",
        .dataTypeSpecific.clazz = GPBObjCClass(PushData),
        .number = DownMsg_FieldNumber_PushData,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(DownMsg__storage_, pushData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mentionInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(MentionInfo),
        .number = DownMsg_FieldNumber_MentionInfo,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(DownMsg__storage_, mentionInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isRead",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsg_FieldNumber_IsRead,
        .hasIndex = 15,
        .offset = 16,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "referMsg",
        .dataTypeSpecific.clazz = GPBObjCClass(DownMsg),
        .number = DownMsg_FieldNumber_ReferMsg,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(DownMsg__storage_, referMsg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "targetUserInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(UserInfo),
        .number = DownMsg_FieldNumber_TargetUserInfo,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(DownMsg__storage_, targetUserInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(GroupInfo),
        .number = DownMsg_FieldNumber_GroupInfo,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(DownMsg__storage_, groupInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mergedMsgs",
        .dataTypeSpecific.clazz = GPBObjCClass(MergedMsgs),
        .number = DownMsg_FieldNumber_MergedMsgs,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(DownMsg__storage_, mergedMsgs),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "undisturbType",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsg_FieldNumber_UndisturbType,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(DownMsg__storage_, undisturbType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "memberCount",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsg_FieldNumber_MemberCount,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(DownMsg__storage_, memberCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "readCount",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsg_FieldNumber_ReadCount,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(DownMsg__storage_, readCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "unreadIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsg_FieldNumber_UnreadIndex,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(DownMsg__storage_, unreadIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DownMsg)
                                   messageName:@"DownMsg"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DownMsg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\025\001\010\000\002\013\000\003\007\000\004\010\000\005\005\000\006\010\000\007\n\000\010\007\000\n\006\000\014\t\000\r\010\000\016\013\000\017\006\000"
        "\020\010\000\021\016\000\022\t\000\023\n\000\024\r\000\025\013\000\026\t\000\027\013\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t DownMsg_ChannelType_RawValue(DownMsg *message) {
  GPBDescriptor *descriptor = [DownMsg descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DownMsg_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetDownMsg_ChannelType_RawValue(DownMsg *message, int32_t value) {
  GPBDescriptor *descriptor = [DownMsg descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DownMsg_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Notify

@implementation Notify

@dynamic type;
@dynamic syncTime;
@dynamic chatroomId;

typedef struct Notify__storage_ {
  uint32_t _has_storage_[1];
  NotifyType type;
  NSString *chatroomId;
  int64_t syncTime;
} Notify__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = NotifyType_EnumDescriptor,
        .number = Notify_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Notify__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "syncTime",
        .dataTypeSpecific.clazz = Nil,
        .number = Notify_FieldNumber_SyncTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Notify__storage_, syncTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "chatroomId",
        .dataTypeSpecific.clazz = Nil,
        .number = Notify_FieldNumber_ChatroomId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Notify__storage_, chatroomId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Notify)
                                   messageName:@"Notify"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Notify__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\002\010\000\003\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Notify_Type_RawValue(Notify *message) {
  GPBDescriptor *descriptor = [Notify descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Notify_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetNotify_Type_RawValue(Notify *message, int32_t value) {
  GPBDescriptor *descriptor = [Notify descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Notify_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - SyncMsgReq

@implementation SyncMsgReq

@dynamic syncTime;
@dynamic containsSendBox;
@dynamic sendBoxSyncTime;
@dynamic chatroomId;

typedef struct SyncMsgReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *chatroomId;
  int64_t syncTime;
  int64_t sendBoxSyncTime;
} SyncMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "syncTime",
        .dataTypeSpecific.clazz = Nil,
        .number = SyncMsgReq_FieldNumber_SyncTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SyncMsgReq__storage_, syncTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "containsSendBox",
        .dataTypeSpecific.clazz = Nil,
        .number = SyncMsgReq_FieldNumber_ContainsSendBox,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "sendBoxSyncTime",
        .dataTypeSpecific.clazz = Nil,
        .number = SyncMsgReq_FieldNumber_SendBoxSyncTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SyncMsgReq__storage_, sendBoxSyncTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "chatroomId",
        .dataTypeSpecific.clazz = Nil,
        .number = SyncMsgReq_FieldNumber_ChatroomId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SyncMsgReq__storage_, chatroomId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SyncMsgReq)
                                   messageName:@"SyncMsgReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncMsgReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\004\001\010\000\002\017\000\003\017\000\004\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DownMsgSet

@implementation DownMsgSet

@dynamic msgsArray, msgsArray_Count;
@dynamic syncTime;
@dynamic isFinished;
@dynamic hasTargetUserInfo, targetUserInfo;
@dynamic hasGroupInfo, groupInfo;

typedef struct DownMsgSet__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *msgsArray;
  UserInfo *targetUserInfo;
  GroupInfo *groupInfo;
  int64_t syncTime;
} DownMsgSet__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DownMsg),
        .number = DownMsgSet_FieldNumber_MsgsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DownMsgSet__storage_, msgsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "syncTime",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsgSet_FieldNumber_SyncTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DownMsgSet__storage_, syncTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isFinished",
        .dataTypeSpecific.clazz = Nil,
        .number = DownMsgSet_FieldNumber_IsFinished,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "targetUserInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(UserInfo),
        .number = DownMsgSet_FieldNumber_TargetUserInfo,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DownMsgSet__storage_, targetUserInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(GroupInfo),
        .number = DownMsgSet_FieldNumber_GroupInfo,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DownMsgSet__storage_, groupInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DownMsgSet)
                                   messageName:@"DownMsgSet"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DownMsgSet__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\004\002\010\000\003\n\000\004\016\000\005\t\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - KvItem

@implementation KvItem

@dynamic key;
@dynamic value;

typedef struct KvItem__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
  NSString *value;
} KvItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = KvItem_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(KvItem__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = KvItem_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(KvItem__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(KvItem)
                                   messageName:@"KvItem"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(KvItem__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddGrpAssistantReq

@implementation AddGrpAssistantReq

@dynamic assistantId;
@dynamic targetsArray, targetsArray_Count;

typedef struct AddGrpAssistantReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *assistantId;
  NSMutableArray *targetsArray;
} AddGrpAssistantReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "assistantId",
        .dataTypeSpecific.clazz = Nil,
        .number = AddGrpAssistantReq_FieldNumber_AssistantId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddGrpAssistantReq__storage_, assistantId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SimpleConversation),
        .number = AddGrpAssistantReq_FieldNumber_TargetsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AddGrpAssistantReq__storage_, targetsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(AddGrpAssistantReq)
                                   messageName:@"AddGrpAssistantReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddGrpAssistantReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\013\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SimpleConversation

@implementation SimpleConversation

@dynamic targetId;
@dynamic channelType;
@dynamic msgTime;
@dynamic msgSeq;

typedef struct SimpleConversation__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  NSString *targetId;
  int64_t msgTime;
  int64_t msgSeq;
} SimpleConversation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = SimpleConversation_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SimpleConversation__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = SimpleConversation_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SimpleConversation__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msgTime",
        .dataTypeSpecific.clazz = Nil,
        .number = SimpleConversation_FieldNumber_MsgTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SimpleConversation__storage_, msgTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msgSeq",
        .dataTypeSpecific.clazz = Nil,
        .number = SimpleConversation_FieldNumber_MsgSeq,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SimpleConversation__storage_, msgSeq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SimpleConversation)
                                   messageName:@"SimpleConversation"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SimpleConversation__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\004\001\010\000\002\013\000\003\007\000\004\006\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SimpleConversation_ChannelType_RawValue(SimpleConversation *message) {
  GPBDescriptor *descriptor = [SimpleConversation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SimpleConversation_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSimpleConversation_ChannelType_RawValue(SimpleConversation *message, int32_t value) {
  GPBDescriptor *descriptor = [SimpleConversation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SimpleConversation_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - AssistantMsgResp

@implementation AssistantMsgResp

@dynamic msgId;
@dynamic msgTime;
@dynamic msgSeq;
@dynamic conversArray, conversArray_Count;

typedef struct AssistantMsgResp__storage_ {
  uint32_t _has_storage_[1];
  NSString *msgId;
  NSMutableArray *conversArray;
  int64_t msgTime;
  int64_t msgSeq;
} AssistantMsgResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.clazz = Nil,
        .number = AssistantMsgResp_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AssistantMsgResp__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgTime",
        .dataTypeSpecific.clazz = Nil,
        .number = AssistantMsgResp_FieldNumber_MsgTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AssistantMsgResp__storage_, msgTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msgSeq",
        .dataTypeSpecific.clazz = Nil,
        .number = AssistantMsgResp_FieldNumber_MsgSeq,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AssistantMsgResp__storage_, msgSeq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "conversArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SimpleConversation),
        .number = AssistantMsgResp_FieldNumber_ConversArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AssistantMsgResp__storage_, conversArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(AssistantMsgResp)
                                   messageName:@"AssistantMsgResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AssistantMsgResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\005\000\002\007\000\003\006\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddHisMsgReq

@implementation AddHisMsgReq

@dynamic senderId;
@dynamic targetId;
@dynamic channelType;
@dynamic sendTime;
@dynamic hasMsg, msg;
@dynamic groupMemberCount;

typedef struct AddHisMsgReq__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  int32_t groupMemberCount;
  NSString *senderId;
  NSString *targetId;
  DownMsg *msg;
  int64_t sendTime;
} AddHisMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "senderId",
        .dataTypeSpecific.clazz = Nil,
        .number = AddHisMsgReq_FieldNumber_SenderId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddHisMsgReq__storage_, senderId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = AddHisMsgReq_FieldNumber_TargetId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddHisMsgReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = AddHisMsgReq_FieldNumber_ChannelType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AddHisMsgReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sendTime",
        .dataTypeSpecific.clazz = Nil,
        .number = AddHisMsgReq_FieldNumber_SendTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AddHisMsgReq__storage_, sendTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(DownMsg),
        .number = AddHisMsgReq_FieldNumber_Msg,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AddHisMsgReq__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupMemberCount",
        .dataTypeSpecific.clazz = Nil,
        .number = AddHisMsgReq_FieldNumber_GroupMemberCount,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AddHisMsgReq__storage_, groupMemberCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(AddHisMsgReq)
                                   messageName:@"AddHisMsgReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddHisMsgReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\005\001\010\000\002\010\000\003\013\000\004\010\000\006P\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t AddHisMsgReq_ChannelType_RawValue(AddHisMsgReq *message) {
  GPBDescriptor *descriptor = [AddHisMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AddHisMsgReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetAddHisMsgReq_ChannelType_RawValue(AddHisMsgReq *message, int32_t value) {
  GPBDescriptor *descriptor = [AddHisMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AddHisMsgReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - DelHisMsgsReq

@implementation DelHisMsgsReq

@dynamic fromId;
@dynamic targetId;
@dynamic channelType;
@dynamic msgsArray, msgsArray_Count;

typedef struct DelHisMsgsReq__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  NSString *fromId;
  NSString *targetId;
  NSMutableArray *msgsArray;
} DelHisMsgsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fromId",
        .dataTypeSpecific.clazz = Nil,
        .number = DelHisMsgsReq_FieldNumber_FromId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DelHisMsgsReq__storage_, fromId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = DelHisMsgsReq_FieldNumber_TargetId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DelHisMsgsReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = DelHisMsgsReq_FieldNumber_ChannelType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DelHisMsgsReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msgsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SimpleMsg),
        .number = DelHisMsgsReq_FieldNumber_MsgsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DelHisMsgsReq__storage_, msgsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DelHisMsgsReq)
                                   messageName:@"DelHisMsgsReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DelHisMsgsReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\006\000\002\010\000\003\013\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t DelHisMsgsReq_ChannelType_RawValue(DelHisMsgsReq *message) {
  GPBDescriptor *descriptor = [DelHisMsgsReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DelHisMsgsReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetDelHisMsgsReq_ChannelType_RawValue(DelHisMsgsReq *message, int32_t value) {
  GPBDescriptor *descriptor = [DelHisMsgsReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DelHisMsgsReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryMsgLatestIndexReq

@implementation QryMsgLatestIndexReq

@dynamic converId;
@dynamic channelType;

typedef struct QryMsgLatestIndexReq__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  NSString *converId;
} QryMsgLatestIndexReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "converId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryMsgLatestIndexReq_FieldNumber_ConverId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryMsgLatestIndexReq__storage_, converId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = QryMsgLatestIndexReq_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryMsgLatestIndexReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryMsgLatestIndexReq)
                                   messageName:@"QryMsgLatestIndexReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryMsgLatestIndexReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\010\000\002\013\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t QryMsgLatestIndexReq_ChannelType_RawValue(QryMsgLatestIndexReq *message) {
  GPBDescriptor *descriptor = [QryMsgLatestIndexReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryMsgLatestIndexReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetQryMsgLatestIndexReq_ChannelType_RawValue(QryMsgLatestIndexReq *message, int32_t value) {
  GPBDescriptor *descriptor = [QryMsgLatestIndexReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryMsgLatestIndexReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryMsgLatestIndexResp

@implementation QryMsgLatestIndexResp

@dynamic converId;
@dynamic channelType;
@dynamic msgSeqNo;

typedef struct QryMsgLatestIndexResp__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  NSString *converId;
  int64_t msgSeqNo;
} QryMsgLatestIndexResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "converId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryMsgLatestIndexResp_FieldNumber_ConverId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryMsgLatestIndexResp__storage_, converId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = QryMsgLatestIndexResp_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryMsgLatestIndexResp__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msgSeqNo",
        .dataTypeSpecific.clazz = Nil,
        .number = QryMsgLatestIndexResp_FieldNumber_MsgSeqNo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(QryMsgLatestIndexResp__storage_, msgSeqNo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryMsgLatestIndexResp)
                                   messageName:@"QryMsgLatestIndexResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryMsgLatestIndexResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\010\000\002K\000\003\010\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t QryMsgLatestIndexResp_ChannelType_RawValue(QryMsgLatestIndexResp *message) {
  GPBDescriptor *descriptor = [QryMsgLatestIndexResp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryMsgLatestIndexResp_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetQryMsgLatestIndexResp_ChannelType_RawValue(QryMsgLatestIndexResp *message, int32_t value) {
  GPBDescriptor *descriptor = [QryMsgLatestIndexResp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryMsgLatestIndexResp_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryHisMsgsReq

@implementation QryHisMsgsReq

@dynamic targetId;
@dynamic channelType;
@dynamic startTime;
@dynamic count;
@dynamic order;
@dynamic msgTypesArray, msgTypesArray_Count;

typedef struct QryHisMsgsReq__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  int32_t count;
  int32_t order;
  NSString *targetId;
  NSMutableArray *msgTypesArray;
  int64_t startTime;
} QryHisMsgsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryHisMsgsReq_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryHisMsgsReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = QryHisMsgsReq_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryHisMsgsReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "startTime",
        .dataTypeSpecific.clazz = Nil,
        .number = QryHisMsgsReq_FieldNumber_StartTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(QryHisMsgsReq__storage_, startTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "count",
        .dataTypeSpecific.clazz = Nil,
        .number = QryHisMsgsReq_FieldNumber_Count,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(QryHisMsgsReq__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "order",
        .dataTypeSpecific.clazz = Nil,
        .number = QryHisMsgsReq_FieldNumber_Order,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(QryHisMsgsReq__storage_, order),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "msgTypesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = QryHisMsgsReq_FieldNumber_MsgTypesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QryHisMsgsReq__storage_, msgTypesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryHisMsgsReq)
                                   messageName:@"QryHisMsgsReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryHisMsgsReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\004\001\010\000\002\013\000\003\t\000\006\000msgTypes\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t QryHisMsgsReq_ChannelType_RawValue(QryHisMsgsReq *message) {
  GPBDescriptor *descriptor = [QryHisMsgsReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryHisMsgsReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetQryHisMsgsReq_ChannelType_RawValue(QryHisMsgsReq *message, int32_t value) {
  GPBDescriptor *descriptor = [QryHisMsgsReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryHisMsgsReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryHisMsgByIdsReq

@implementation QryHisMsgByIdsReq

@dynamic targetId;
@dynamic channelType;
@dynamic msgIdsArray, msgIdsArray_Count;

typedef struct QryHisMsgByIdsReq__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  NSString *targetId;
  NSMutableArray *msgIdsArray;
} QryHisMsgByIdsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryHisMsgByIdsReq_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryHisMsgByIdsReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = QryHisMsgByIdsReq_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryHisMsgByIdsReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msgIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = QryHisMsgByIdsReq_FieldNumber_MsgIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QryHisMsgByIdsReq__storage_, msgIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryHisMsgByIdsReq)
                                   messageName:@"QryHisMsgByIdsReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryHisMsgByIdsReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\010\000\002\013\000\003\000msgIds\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t QryHisMsgByIdsReq_ChannelType_RawValue(QryHisMsgByIdsReq *message) {
  GPBDescriptor *descriptor = [QryHisMsgByIdsReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryHisMsgByIdsReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetQryHisMsgByIdsReq_ChannelType_RawValue(QryHisMsgByIdsReq *message, int32_t value) {
  GPBDescriptor *descriptor = [QryHisMsgByIdsReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryHisMsgByIdsReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - RecallMsgReq

@implementation RecallMsgReq

@dynamic targetId;
@dynamic channelType;
@dynamic msgId;
@dynamic msgTime;
@dynamic extsArray, extsArray_Count;

typedef struct RecallMsgReq__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  NSString *targetId;
  NSString *msgId;
  NSMutableArray *extsArray;
  int64_t msgTime;
} RecallMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = RecallMsgReq_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RecallMsgReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = RecallMsgReq_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RecallMsgReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.clazz = Nil,
        .number = RecallMsgReq_FieldNumber_MsgId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RecallMsgReq__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgTime",
        .dataTypeSpecific.clazz = Nil,
        .number = RecallMsgReq_FieldNumber_MsgTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RecallMsgReq__storage_, msgTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "extsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(KvItem),
        .number = RecallMsgReq_FieldNumber_ExtsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RecallMsgReq__storage_, extsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(RecallMsgReq)
                                   messageName:@"RecallMsgReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RecallMsgReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\004\001\010\000\002\013\000\003\005\000\004\007\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RecallMsgReq_ChannelType_RawValue(RecallMsgReq *message) {
  GPBDescriptor *descriptor = [RecallMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RecallMsgReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetRecallMsgReq_ChannelType_RawValue(RecallMsgReq *message, int32_t value) {
  GPBDescriptor *descriptor = [RecallMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RecallMsgReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - MarkReadReq

@implementation MarkReadReq

@dynamic targetId;
@dynamic channelType;
@dynamic msgsArray, msgsArray_Count;
@dynamic indexScopesArray, indexScopesArray_Count;

typedef struct MarkReadReq__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  NSString *targetId;
  NSMutableArray *msgsArray;
  NSMutableArray *indexScopesArray;
} MarkReadReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = MarkReadReq_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MarkReadReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = MarkReadReq_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MarkReadReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msgsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SimpleMsg),
        .number = MarkReadReq_FieldNumber_MsgsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MarkReadReq__storage_, msgsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "indexScopesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(IndexScope),
        .number = MarkReadReq_FieldNumber_IndexScopesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MarkReadReq__storage_, indexScopesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MarkReadReq)
                                   messageName:@"MarkReadReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MarkReadReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\010\000\002\013\000\004\000indexScopes\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t MarkReadReq_ChannelType_RawValue(MarkReadReq *message) {
  GPBDescriptor *descriptor = [MarkReadReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MarkReadReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetMarkReadReq_ChannelType_RawValue(MarkReadReq *message, int32_t value) {
  GPBDescriptor *descriptor = [MarkReadReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MarkReadReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - MarkGrpMsgReadReq

@implementation MarkGrpMsgReadReq

@dynamic groupId;
@dynamic channelType;
@dynamic msgIdsArray, msgIdsArray_Count;

typedef struct MarkGrpMsgReadReq__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  NSString *groupId;
  NSMutableArray *msgIdsArray;
} MarkGrpMsgReadReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = MarkGrpMsgReadReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MarkGrpMsgReadReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = MarkGrpMsgReadReq_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MarkGrpMsgReadReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msgIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = MarkGrpMsgReadReq_FieldNumber_MsgIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MarkGrpMsgReadReq__storage_, msgIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MarkGrpMsgReadReq)
                                   messageName:@"MarkGrpMsgReadReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MarkGrpMsgReadReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\007\000\002\013\000\003\000msgIds\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t MarkGrpMsgReadReq_ChannelType_RawValue(MarkGrpMsgReadReq *message) {
  GPBDescriptor *descriptor = [MarkGrpMsgReadReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MarkGrpMsgReadReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetMarkGrpMsgReadReq_ChannelType_RawValue(MarkGrpMsgReadReq *message, int32_t value) {
  GPBDescriptor *descriptor = [MarkGrpMsgReadReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MarkGrpMsgReadReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - CleanHisMsgReq

@implementation CleanHisMsgReq

@dynamic targetId;
@dynamic channelType;
@dynamic cleanMsgTime;
@dynamic cleanScope;

typedef struct CleanHisMsgReq__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  int32_t cleanScope;
  NSString *targetId;
  int64_t cleanMsgTime;
} CleanHisMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = CleanHisMsgReq_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CleanHisMsgReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = CleanHisMsgReq_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CleanHisMsgReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "cleanMsgTime",
        .dataTypeSpecific.clazz = Nil,
        .number = CleanHisMsgReq_FieldNumber_CleanMsgTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CleanHisMsgReq__storage_, cleanMsgTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "cleanScope",
        .dataTypeSpecific.clazz = Nil,
        .number = CleanHisMsgReq_FieldNumber_CleanScope,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CleanHisMsgReq__storage_, cleanScope),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(CleanHisMsgReq)
                                   messageName:@"CleanHisMsgReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CleanHisMsgReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\004\001\010\000\002\013\000\003\014\000\004\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CleanHisMsgReq_ChannelType_RawValue(CleanHisMsgReq *message) {
  GPBDescriptor *descriptor = [CleanHisMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CleanHisMsgReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetCleanHisMsgReq_ChannelType_RawValue(CleanHisMsgReq *message, int32_t value) {
  GPBDescriptor *descriptor = [CleanHisMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CleanHisMsgReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - DestroyHisMsgReq

@implementation DestroyHisMsgReq

@dynamic fromId;
@dynamic targetId;
@dynamic channelType;
@dynamic destroyTime;

typedef struct DestroyHisMsgReq__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  NSString *fromId;
  NSString *targetId;
  int64_t destroyTime;
} DestroyHisMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fromId",
        .dataTypeSpecific.clazz = Nil,
        .number = DestroyHisMsgReq_FieldNumber_FromId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DestroyHisMsgReq__storage_, fromId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = DestroyHisMsgReq_FieldNumber_TargetId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DestroyHisMsgReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = DestroyHisMsgReq_FieldNumber_ChannelType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DestroyHisMsgReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "destroyTime",
        .dataTypeSpecific.clazz = Nil,
        .number = DestroyHisMsgReq_FieldNumber_DestroyTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DestroyHisMsgReq__storage_, destroyTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DestroyHisMsgReq)
                                   messageName:@"DestroyHisMsgReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DestroyHisMsgReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\004\001\006\000\002\010\000\003\013\000\004\013\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t DestroyHisMsgReq_ChannelType_RawValue(DestroyHisMsgReq *message) {
  GPBDescriptor *descriptor = [DestroyHisMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DestroyHisMsgReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetDestroyHisMsgReq_ChannelType_RawValue(DestroyHisMsgReq *message, int32_t value) {
  GPBDescriptor *descriptor = [DestroyHisMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DestroyHisMsgReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - SimpleMsg

@implementation SimpleMsg

@dynamic msgId;
@dynamic msgTime;
@dynamic msgReadIndex;

typedef struct SimpleMsg__storage_ {
  uint32_t _has_storage_[1];
  NSString *msgId;
  int64_t msgTime;
  int64_t msgReadIndex;
} SimpleMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.clazz = Nil,
        .number = SimpleMsg_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SimpleMsg__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgTime",
        .dataTypeSpecific.clazz = Nil,
        .number = SimpleMsg_FieldNumber_MsgTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SimpleMsg__storage_, msgTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msgReadIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = SimpleMsg_FieldNumber_MsgReadIndex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SimpleMsg__storage_, msgReadIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SimpleMsg)
                                   messageName:@"SimpleMsg"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SimpleMsg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\005\000\002\007\000\003\014\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IndexScope

@implementation IndexScope

@dynamic startIndex;
@dynamic endIndex;

typedef struct IndexScope__storage_ {
  uint32_t _has_storage_[1];
  int64_t startIndex;
  int64_t endIndex;
} IndexScope__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = IndexScope_FieldNumber_StartIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IndexScope__storage_, startIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = IndexScope_FieldNumber_EndIndex,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IndexScope__storage_, endIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(IndexScope)
                                   messageName:@"IndexScope"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IndexScope__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\n\000\002\010\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ModifyMsgReq

@implementation ModifyMsgReq

@dynamic targetId;
@dynamic channelType;
@dynamic msgId;
@dynamic msgTime;
@dynamic msgSeqNo;
@dynamic msgContent;

typedef struct ModifyMsgReq__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  NSString *targetId;
  NSString *msgId;
  NSData *msgContent;
  int64_t msgTime;
  int64_t msgSeqNo;
} ModifyMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = ModifyMsgReq_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ModifyMsgReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = ModifyMsgReq_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ModifyMsgReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.clazz = Nil,
        .number = ModifyMsgReq_FieldNumber_MsgId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ModifyMsgReq__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgTime",
        .dataTypeSpecific.clazz = Nil,
        .number = ModifyMsgReq_FieldNumber_MsgTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ModifyMsgReq__storage_, msgTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msgSeqNo",
        .dataTypeSpecific.clazz = Nil,
        .number = ModifyMsgReq_FieldNumber_MsgSeqNo,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ModifyMsgReq__storage_, msgSeqNo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msgContent",
        .dataTypeSpecific.clazz = Nil,
        .number = ModifyMsgReq_FieldNumber_MsgContent,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ModifyMsgReq__storage_, msgContent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ModifyMsgReq)
                                   messageName:@"ModifyMsgReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ModifyMsgReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\006\001\010\000\002\013\000\003\005\000\004\007\000\005\010\000\006\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ModifyMsgReq_ChannelType_RawValue(ModifyMsgReq *message) {
  GPBDescriptor *descriptor = [ModifyMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ModifyMsgReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetModifyMsgReq_ChannelType_RawValue(ModifyMsgReq *message, int32_t value) {
  GPBDescriptor *descriptor = [ModifyMsgReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ModifyMsgReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - MergeMsgReq

@implementation MergeMsgReq

@dynamic parentMsgId;
@dynamic hasMergedMsgs, mergedMsgs;

typedef struct MergeMsgReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *parentMsgId;
  MergedMsgs *mergedMsgs;
} MergeMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "parentMsgId",
        .dataTypeSpecific.clazz = Nil,
        .number = MergeMsgReq_FieldNumber_ParentMsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MergeMsgReq__storage_, parentMsgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mergedMsgs",
        .dataTypeSpecific.clazz = GPBObjCClass(MergedMsgs),
        .number = MergeMsgReq_FieldNumber_MergedMsgs,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MergeMsgReq__storage_, mergedMsgs),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MergeMsgReq)
                                   messageName:@"MergeMsgReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MergeMsgReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\013\000\002\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QryMergedMsgsReq

@implementation QryMergedMsgsReq

@dynamic startTime;
@dynamic count;
@dynamic order;

typedef struct QryMergedMsgsReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
  int32_t order;
  int64_t startTime;
} QryMergedMsgsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startTime",
        .dataTypeSpecific.clazz = Nil,
        .number = QryMergedMsgsReq_FieldNumber_StartTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryMergedMsgsReq__storage_, startTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "count",
        .dataTypeSpecific.clazz = Nil,
        .number = QryMergedMsgsReq_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryMergedMsgsReq__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "order",
        .dataTypeSpecific.clazz = Nil,
        .number = QryMergedMsgsReq_FieldNumber_Order,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(QryMergedMsgsReq__storage_, order),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryMergedMsgsReq)
                                   messageName:@"QryMergedMsgsReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryMergedMsgsReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\t\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MsgExtItem

@implementation MsgExtItem

@dynamic msgId;
@dynamic targetId;
@dynamic channelType;
@dynamic key;
@dynamic value;

typedef struct MsgExtItem__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  NSString *msgId;
  NSString *targetId;
  NSString *key;
  NSString *value;
} MsgExtItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.clazz = Nil,
        .number = MsgExtItem_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MsgExtItem__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = MsgExtItem_FieldNumber_TargetId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MsgExtItem__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = MsgExtItem_FieldNumber_ChannelType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MsgExtItem__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = MsgExtItem_FieldNumber_Key,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MsgExtItem__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = MsgExtItem_FieldNumber_Value,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MsgExtItem__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MsgExtItem)
                                   messageName:@"MsgExtItem"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MsgExtItem__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\005\000\002\010\000\003\013\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t MsgExtItem_ChannelType_RawValue(MsgExtItem *message) {
  GPBDescriptor *descriptor = [MsgExtItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MsgExtItem_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetMsgExtItem_ChannelType_RawValue(MsgExtItem *message, int32_t value) {
  GPBDescriptor *descriptor = [MsgExtItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MsgExtItem_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryGlobalConversReq

@implementation QryGlobalConversReq

@dynamic startTime;
@dynamic count;
@dynamic order;
@dynamic targetId;
@dynamic channelType;

typedef struct QryGlobalConversReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
  int32_t order;
  ChannelType channelType;
  NSString *targetId;
  int64_t startTime;
} QryGlobalConversReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startTime",
        .dataTypeSpecific.clazz = Nil,
        .number = QryGlobalConversReq_FieldNumber_StartTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryGlobalConversReq__storage_, startTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "count",
        .dataTypeSpecific.clazz = Nil,
        .number = QryGlobalConversReq_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryGlobalConversReq__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "order",
        .dataTypeSpecific.clazz = Nil,
        .number = QryGlobalConversReq_FieldNumber_Order,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(QryGlobalConversReq__storage_, order),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryGlobalConversReq_FieldNumber_TargetId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(QryGlobalConversReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = QryGlobalConversReq_FieldNumber_ChannelType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(QryGlobalConversReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryGlobalConversReq)
                                   messageName:@"QryGlobalConversReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryGlobalConversReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\t\000\004\010\000\005\013\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t QryGlobalConversReq_ChannelType_RawValue(QryGlobalConversReq *message) {
  GPBDescriptor *descriptor = [QryGlobalConversReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryGlobalConversReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetQryGlobalConversReq_ChannelType_RawValue(QryGlobalConversReq *message, int32_t value) {
  GPBDescriptor *descriptor = [QryGlobalConversReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryGlobalConversReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryGlobalConversResp

@implementation QryGlobalConversResp

@dynamic conversArray, conversArray_Count;
@dynamic isFinished;

typedef struct QryGlobalConversResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *conversArray;
} QryGlobalConversResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "conversArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GlobalConver),
        .number = QryGlobalConversResp_FieldNumber_ConversArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QryGlobalConversResp__storage_, conversArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isFinished",
        .dataTypeSpecific.clazz = Nil,
        .number = QryGlobalConversResp_FieldNumber_IsFinished,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryGlobalConversResp)
                                   messageName:@"QryGlobalConversResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryGlobalConversResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\002\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GlobalConver

@implementation GlobalConver

@dynamic converId;
@dynamic senderId;
@dynamic targetId;
@dynamic channelType;
@dynamic updatedTime;

typedef struct GlobalConver__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  NSString *converId;
  NSString *senderId;
  NSString *targetId;
  int64_t updatedTime;
} GlobalConver__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "converId",
        .dataTypeSpecific.clazz = Nil,
        .number = GlobalConver_FieldNumber_ConverId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GlobalConver__storage_, converId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "senderId",
        .dataTypeSpecific.clazz = Nil,
        .number = GlobalConver_FieldNumber_SenderId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GlobalConver__storage_, senderId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = GlobalConver_FieldNumber_TargetId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GlobalConver__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = GlobalConver_FieldNumber_ChannelType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GlobalConver__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "updatedTime",
        .dataTypeSpecific.clazz = Nil,
        .number = GlobalConver_FieldNumber_UpdatedTime,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GlobalConver__storage_, updatedTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GlobalConver)
                                   messageName:@"GlobalConver"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GlobalConver__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\005\001\010\000\002\010\000\003\010\000\004\013\000\005\013\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GlobalConver_ChannelType_RawValue(GlobalConver *message) {
  GPBDescriptor *descriptor = [GlobalConver descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GlobalConver_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetGlobalConver_ChannelType_RawValue(GlobalConver *message, int32_t value) {
  GPBDescriptor *descriptor = [GlobalConver descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GlobalConver_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryConversationsReq

@implementation QryConversationsReq

@dynamic startTime;
@dynamic count;
@dynamic order;
@dynamic userId;
@dynamic targetId;
@dynamic channelType;

typedef struct QryConversationsReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
  int32_t order;
  ChannelType channelType;
  NSString *userId;
  NSString *targetId;
  int64_t startTime;
} QryConversationsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startTime",
        .dataTypeSpecific.clazz = Nil,
        .number = QryConversationsReq_FieldNumber_StartTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryConversationsReq__storage_, startTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "count",
        .dataTypeSpecific.clazz = Nil,
        .number = QryConversationsReq_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryConversationsReq__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "order",
        .dataTypeSpecific.clazz = Nil,
        .number = QryConversationsReq_FieldNumber_Order,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(QryConversationsReq__storage_, order),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryConversationsReq_FieldNumber_UserId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(QryConversationsReq__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryConversationsReq_FieldNumber_TargetId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(QryConversationsReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = QryConversationsReq_FieldNumber_ChannelType,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(QryConversationsReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryConversationsReq)
                                   messageName:@"QryConversationsReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryConversationsReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\004\001\t\000\004\006\000\005\010\000\006\013\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t QryConversationsReq_ChannelType_RawValue(QryConversationsReq *message) {
  GPBDescriptor *descriptor = [QryConversationsReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryConversationsReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetQryConversationsReq_ChannelType_RawValue(QryConversationsReq *message, int32_t value) {
  GPBDescriptor *descriptor = [QryConversationsReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryConversationsReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryConversationsResp

@implementation QryConversationsResp

@dynamic conversationsArray, conversationsArray_Count;
@dynamic isFinished;

typedef struct QryConversationsResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *conversationsArray;
} QryConversationsResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "conversationsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Conversation),
        .number = QryConversationsResp_FieldNumber_ConversationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QryConversationsResp__storage_, conversationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isFinished",
        .dataTypeSpecific.clazz = Nil,
        .number = QryConversationsResp_FieldNumber_IsFinished,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryConversationsResp)
                                   messageName:@"QryConversationsResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryConversationsResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\002\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Conversation

@implementation Conversation

@dynamic userId;
@dynamic targetId;
@dynamic channelType;
@dynamic sortTime;
@dynamic unreadCount;
@dynamic hasMsg, msg;
@dynamic latestReadIndex;
@dynamic hasLatestMentionMsg, latestMentionMsg;
@dynamic isTop;
@dynamic topUpdatedTime;
@dynamic undisturbType;
@dynamic hasTargetUserInfo, targetUserInfo;
@dynamic hasGroupInfo, groupInfo;
@dynamic syncTime;
@dynamic isDelete;
@dynamic latestUnreadIndex;

typedef struct Conversation__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  int32_t isTop;
  int32_t undisturbType;
  int32_t isDelete;
  NSString *userId;
  NSString *targetId;
  DownMsg *msg;
  MentionMsg *latestMentionMsg;
  UserInfo *targetUserInfo;
  GroupInfo *groupInfo;
  int64_t sortTime;
  int64_t unreadCount;
  int64_t latestReadIndex;
  int64_t topUpdatedTime;
  int64_t syncTime;
  int64_t latestUnreadIndex;
} Conversation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = Conversation_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Conversation__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = Conversation_FieldNumber_TargetId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Conversation__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = Conversation_FieldNumber_ChannelType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Conversation__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sortTime",
        .dataTypeSpecific.clazz = Nil,
        .number = Conversation_FieldNumber_SortTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Conversation__storage_, sortTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "unreadCount",
        .dataTypeSpecific.clazz = Nil,
        .number = Conversation_FieldNumber_UnreadCount,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Conversation__storage_, unreadCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(DownMsg),
        .number = Conversation_FieldNumber_Msg,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Conversation__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "latestReadIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = Conversation_FieldNumber_LatestReadIndex,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Conversation__storage_, latestReadIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "latestMentionMsg",
        .dataTypeSpecific.clazz = GPBObjCClass(MentionMsg),
        .number = Conversation_FieldNumber_LatestMentionMsg,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Conversation__storage_, latestMentionMsg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isTop",
        .dataTypeSpecific.clazz = Nil,
        .number = Conversation_FieldNumber_IsTop,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Conversation__storage_, isTop),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "topUpdatedTime",
        .dataTypeSpecific.clazz = Nil,
        .number = Conversation_FieldNumber_TopUpdatedTime,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Conversation__storage_, topUpdatedTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "undisturbType",
        .dataTypeSpecific.clazz = Nil,
        .number = Conversation_FieldNumber_UndisturbType,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Conversation__storage_, undisturbType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "targetUserInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(UserInfo),
        .number = Conversation_FieldNumber_TargetUserInfo,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Conversation__storage_, targetUserInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(GroupInfo),
        .number = Conversation_FieldNumber_GroupInfo,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(Conversation__storage_, groupInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "syncTime",
        .dataTypeSpecific.clazz = Nil,
        .number = Conversation_FieldNumber_SyncTime,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(Conversation__storage_, syncTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isDelete",
        .dataTypeSpecific.clazz = Nil,
        .number = Conversation_FieldNumber_IsDelete,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(Conversation__storage_, isDelete),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "latestUnreadIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = Conversation_FieldNumber_LatestUnreadIndex,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(Conversation__storage_, latestUnreadIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Conversation)
                                   messageName:@"Conversation"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Conversation__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\017\001\006\000\002\010\000\003\013\000\004\010\000\005\013\000\007\017\000\010P\000\t\005\000\n\016\000\013\r\000\014\016\000\r\t\000\016\010\000"
        "\017\010\000\020\021\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Conversation_ChannelType_RawValue(Conversation *message) {
  GPBDescriptor *descriptor = [Conversation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Conversation_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetConversation_ChannelType_RawValue(Conversation *message, int32_t value) {
  GPBDescriptor *descriptor = [Conversation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Conversation_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - MentionInfos

@implementation MentionInfos


typedef struct MentionInfos__storage_ {
  uint32_t _has_storage_[1];
} MentionInfos__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MentionInfos)
                                   messageName:@"MentionInfos"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(MentionInfos__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MentionMsg

@implementation MentionMsg

@dynamic mentionType;
@dynamic hasSenderInfo, senderInfo;
@dynamic hasMsg, msg;

typedef struct MentionMsg__storage_ {
  uint32_t _has_storage_[1];
  MentionType mentionType;
  UserInfo *senderInfo;
  DownMsg *msg;
} MentionMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mentionType",
        .dataTypeSpecific.enumDescFunc = MentionType_EnumDescriptor,
        .number = MentionMsg_FieldNumber_MentionType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MentionMsg__storage_, mentionType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "senderInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(UserInfo),
        .number = MentionMsg_FieldNumber_SenderInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MentionMsg__storage_, senderInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "msg",
        .dataTypeSpecific.clazz = GPBObjCClass(DownMsg),
        .number = MentionMsg_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MentionMsg__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MentionMsg)
                                   messageName:@"MentionMsg"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MentionMsg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\013\000\002\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t MentionMsg_MentionType_RawValue(MentionMsg *message) {
  GPBDescriptor *descriptor = [MentionMsg descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MentionMsg_FieldNumber_MentionType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetMentionMsg_MentionType_RawValue(MentionMsg *message, int32_t value) {
  GPBDescriptor *descriptor = [MentionMsg descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MentionMsg_FieldNumber_MentionType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryMentionMsgsReq

@implementation QryMentionMsgsReq

@dynamic targetId;
@dynamic channelType;
@dynamic startTime;
@dynamic count;
@dynamic order;

typedef struct QryMentionMsgsReq__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  int32_t count;
  int32_t order;
  NSString *targetId;
  int64_t startTime;
} QryMentionMsgsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryMentionMsgsReq_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryMentionMsgsReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = QryMentionMsgsReq_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryMentionMsgsReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "startTime",
        .dataTypeSpecific.clazz = Nil,
        .number = QryMentionMsgsReq_FieldNumber_StartTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(QryMentionMsgsReq__storage_, startTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "count",
        .dataTypeSpecific.clazz = Nil,
        .number = QryMentionMsgsReq_FieldNumber_Count,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(QryMentionMsgsReq__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "order",
        .dataTypeSpecific.clazz = Nil,
        .number = QryMentionMsgsReq_FieldNumber_Order,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(QryMentionMsgsReq__storage_, order),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryMentionMsgsReq)
                                   messageName:@"QryMentionMsgsReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryMentionMsgsReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\010\000\002\013\000\003\t\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t QryMentionMsgsReq_ChannelType_RawValue(QryMentionMsgsReq *message) {
  GPBDescriptor *descriptor = [QryMentionMsgsReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryMentionMsgsReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetQryMentionMsgsReq_ChannelType_RawValue(QryMentionMsgsReq *message, int32_t value) {
  GPBDescriptor *descriptor = [QryMentionMsgsReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryMentionMsgsReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryMentionMsgsResp

@implementation QryMentionMsgsResp

@dynamic mentionMsgsArray, mentionMsgsArray_Count;
@dynamic isFinished;

typedef struct QryMentionMsgsResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *mentionMsgsArray;
} QryMentionMsgsResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mentionMsgsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DownMsg),
        .number = QryMentionMsgsResp_FieldNumber_MentionMsgsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QryMentionMsgsResp__storage_, mentionMsgsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isFinished",
        .dataTypeSpecific.clazz = Nil,
        .number = QryMentionMsgsResp_FieldNumber_IsFinished,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryMentionMsgsResp)
                                   messageName:@"QryMentionMsgsResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryMentionMsgsResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\000mentionMsgs\000\002\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SyncConversationsReq

@implementation SyncConversationsReq

@dynamic startTime;
@dynamic count;

typedef struct SyncConversationsReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
  int64_t startTime;
} SyncConversationsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startTime",
        .dataTypeSpecific.clazz = Nil,
        .number = SyncConversationsReq_FieldNumber_StartTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SyncConversationsReq__storage_, startTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "count",
        .dataTypeSpecific.clazz = Nil,
        .number = SyncConversationsReq_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SyncConversationsReq__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SyncConversationsReq)
                                   messageName:@"SyncConversationsReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncConversationsReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\t\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QryTotalUnreadCountReq

@implementation QryTotalUnreadCountReq

@dynamic time;

typedef struct QryTotalUnreadCountReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t time;
} QryTotalUnreadCountReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "time",
        .dataTypeSpecific.clazz = Nil,
        .number = QryTotalUnreadCountReq_FieldNumber_Time,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryTotalUnreadCountReq__storage_, time),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryTotalUnreadCountReq)
                                   messageName:@"QryTotalUnreadCountReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryTotalUnreadCountReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QryTotalUnreadCountResp

@implementation QryTotalUnreadCountResp

@dynamic totalCount;

typedef struct QryTotalUnreadCountResp__storage_ {
  uint32_t _has_storage_[1];
  int64_t totalCount;
} QryTotalUnreadCountResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "totalCount",
        .dataTypeSpecific.clazz = Nil,
        .number = QryTotalUnreadCountResp_FieldNumber_TotalCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryTotalUnreadCountResp__storage_, totalCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryTotalUnreadCountResp)
                                   messageName:@"QryTotalUnreadCountResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryTotalUnreadCountResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ConversationsReq

@implementation ConversationsReq

@dynamic conversationsArray, conversationsArray_Count;

typedef struct ConversationsReq__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *conversationsArray;
} ConversationsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "conversationsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Conversation),
        .number = ConversationsReq_FieldNumber_ConversationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ConversationsReq__storage_, conversationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ConversationsReq)
                                   messageName:@"ConversationsReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ConversationsReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ClearUnreadReq

@implementation ClearUnreadReq

@dynamic conversationsArray, conversationsArray_Count;

typedef struct ClearUnreadReq__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *conversationsArray;
} ClearUnreadReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "conversationsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Conversation),
        .number = ClearUnreadReq_FieldNumber_ConversationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ClearUnreadReq__storage_, conversationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ClearUnreadReq)
                                   messageName:@"ClearUnreadReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ClearUnreadReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UndisturbConversReq

@implementation UndisturbConversReq

@dynamic userId;
@dynamic itemsArray, itemsArray_Count;

typedef struct UndisturbConversReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  NSMutableArray *itemsArray;
} UndisturbConversReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = UndisturbConversReq_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UndisturbConversReq__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "itemsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UndisturbConverItem),
        .number = UndisturbConversReq_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UndisturbConversReq__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UndisturbConversReq)
                                   messageName:@"UndisturbConversReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UndisturbConversReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\006\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UndisturbConverItem

@implementation UndisturbConverItem

@dynamic targetId;
@dynamic channelType;
@dynamic undisturbType;

typedef struct UndisturbConverItem__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  int32_t undisturbType;
  NSString *targetId;
} UndisturbConverItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = UndisturbConverItem_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UndisturbConverItem__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = UndisturbConverItem_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UndisturbConverItem__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "undisturbType",
        .dataTypeSpecific.clazz = Nil,
        .number = UndisturbConverItem_FieldNumber_UndisturbType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UndisturbConverItem__storage_, undisturbType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UndisturbConverItem)
                                   messageName:@"UndisturbConverItem"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UndisturbConverItem__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\010\000\002\013\000\003\r\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UndisturbConverItem_ChannelType_RawValue(UndisturbConverItem *message) {
  GPBDescriptor *descriptor = [UndisturbConverItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UndisturbConverItem_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetUndisturbConverItem_ChannelType_RawValue(UndisturbConverItem *message, int32_t value) {
  GPBDescriptor *descriptor = [UndisturbConverItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UndisturbConverItem_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryTopConversReq

@implementation QryTopConversReq

@dynamic startTime;

typedef struct QryTopConversReq__storage_ {
  uint32_t _has_storage_[1];
  int64_t startTime;
} QryTopConversReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startTime",
        .dataTypeSpecific.clazz = Nil,
        .number = QryTopConversReq_FieldNumber_StartTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryTopConversReq__storage_, startTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryTopConversReq)
                                   messageName:@"QryTopConversReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryTopConversReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\t\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TopConversResp

@implementation TopConversResp

@dynamic optTime;

typedef struct TopConversResp__storage_ {
  uint32_t _has_storage_[1];
  int64_t optTime;
} TopConversResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "optTime",
        .dataTypeSpecific.clazz = Nil,
        .number = TopConversResp_FieldNumber_OptTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TopConversResp__storage_, optTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(TopConversResp)
                                   messageName:@"TopConversResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TopConversResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\007\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QryReadInfosReq

@implementation QryReadInfosReq

@dynamic targetId;
@dynamic channelType;
@dynamic msgIdsArray, msgIdsArray_Count;

typedef struct QryReadInfosReq__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  NSString *targetId;
  NSMutableArray *msgIdsArray;
} QryReadInfosReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryReadInfosReq_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryReadInfosReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = QryReadInfosReq_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryReadInfosReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msgIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = QryReadInfosReq_FieldNumber_MsgIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QryReadInfosReq__storage_, msgIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryReadInfosReq)
                                   messageName:@"QryReadInfosReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryReadInfosReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\010\000\002\013\000\003\000msgIds\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t QryReadInfosReq_ChannelType_RawValue(QryReadInfosReq *message) {
  GPBDescriptor *descriptor = [QryReadInfosReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryReadInfosReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetQryReadInfosReq_ChannelType_RawValue(QryReadInfosReq *message, int32_t value) {
  GPBDescriptor *descriptor = [QryReadInfosReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryReadInfosReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryReadInfosResp

@implementation QryReadInfosResp

@dynamic itemsArray, itemsArray_Count;

typedef struct QryReadInfosResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemsArray;
} QryReadInfosResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ReadInfoItem),
        .number = QryReadInfosResp_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QryReadInfosResp__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryReadInfosResp)
                                   messageName:@"QryReadInfosResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryReadInfosResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ReadInfoItem

@implementation ReadInfoItem

@dynamic msgId;
@dynamic readCount;
@dynamic totalCount;

typedef struct ReadInfoItem__storage_ {
  uint32_t _has_storage_[1];
  int32_t readCount;
  int32_t totalCount;
  NSString *msgId;
} ReadInfoItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.clazz = Nil,
        .number = ReadInfoItem_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ReadInfoItem__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "readCount",
        .dataTypeSpecific.clazz = Nil,
        .number = ReadInfoItem_FieldNumber_ReadCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ReadInfoItem__storage_, readCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "totalCount",
        .dataTypeSpecific.clazz = Nil,
        .number = ReadInfoItem_FieldNumber_TotalCount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ReadInfoItem__storage_, totalCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ReadInfoItem)
                                   messageName:@"ReadInfoItem"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ReadInfoItem__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\005\000\002\t\000\003\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QryReadDetailReq

@implementation QryReadDetailReq

@dynamic targetId;
@dynamic channelType;
@dynamic msgId;

typedef struct QryReadDetailReq__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  NSString *targetId;
  NSString *msgId;
} QryReadDetailReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryReadDetailReq_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryReadDetailReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = QryReadDetailReq_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryReadDetailReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryReadDetailReq_FieldNumber_MsgId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(QryReadDetailReq__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryReadDetailReq)
                                   messageName:@"QryReadDetailReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryReadDetailReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\010\000\002\013\000\003\005\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t QryReadDetailReq_ChannelType_RawValue(QryReadDetailReq *message) {
  GPBDescriptor *descriptor = [QryReadDetailReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryReadDetailReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetQryReadDetailReq_ChannelType_RawValue(QryReadDetailReq *message, int32_t value) {
  GPBDescriptor *descriptor = [QryReadDetailReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryReadDetailReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryReadDetailResp

@implementation QryReadDetailResp

@dynamic readCount;
@dynamic memberCount;
@dynamic readMembersArray, readMembersArray_Count;
@dynamic unreadMembersArray, unreadMembersArray_Count;

typedef struct QryReadDetailResp__storage_ {
  uint32_t _has_storage_[1];
  int32_t readCount;
  int32_t memberCount;
  NSMutableArray *readMembersArray;
  NSMutableArray *unreadMembersArray;
} QryReadDetailResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "readCount",
        .dataTypeSpecific.clazz = Nil,
        .number = QryReadDetailResp_FieldNumber_ReadCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryReadDetailResp__storage_, readCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "memberCount",
        .dataTypeSpecific.clazz = Nil,
        .number = QryReadDetailResp_FieldNumber_MemberCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryReadDetailResp__storage_, memberCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "readMembersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(MemberReadDetailItem),
        .number = QryReadDetailResp_FieldNumber_ReadMembersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QryReadDetailResp__storage_, readMembersArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "unreadMembersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(MemberReadDetailItem),
        .number = QryReadDetailResp_FieldNumber_UnreadMembersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QryReadDetailResp__storage_, unreadMembersArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryReadDetailResp)
                                   messageName:@"QryReadDetailResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryReadDetailResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\004\001\t\000\002\013\000\003\000readMembers\000\004\000unreadMembers\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MemberReadDetailItem

@implementation MemberReadDetailItem

@dynamic hasMember, member;
@dynamic time;

typedef struct MemberReadDetailItem__storage_ {
  uint32_t _has_storage_[1];
  UserInfo *member;
  int64_t time;
} MemberReadDetailItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "member",
        .dataTypeSpecific.clazz = GPBObjCClass(UserInfo),
        .number = MemberReadDetailItem_FieldNumber_Member,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MemberReadDetailItem__storage_, member),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "time",
        .dataTypeSpecific.clazz = Nil,
        .number = MemberReadDetailItem_FieldNumber_Time,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MemberReadDetailItem__storage_, time),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(MemberReadDetailItem)
                                   messageName:@"MemberReadDetailItem"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MemberReadDetailItem__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QryConverReq

@implementation QryConverReq

@dynamic targetId;
@dynamic channelType;

typedef struct QryConverReq__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  NSString *targetId;
} QryConverReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryConverReq_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryConverReq__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = QryConverReq_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryConverReq__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryConverReq)
                                   messageName:@"QryConverReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryConverReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\010\000\002\013\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t QryConverReq_ChannelType_RawValue(QryConverReq *message) {
  GPBDescriptor *descriptor = [QryConverReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryConverReq_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetQryConverReq_ChannelType_RawValue(QryConverReq *message, int32_t value) {
  GPBDescriptor *descriptor = [QryConverReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryConverReq_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryConverResp

@implementation QryConverResp

@dynamic targetId;
@dynamic channelType;
@dynamic unreadIndex;
@dynamic undisturbType;

typedef struct QryConverResp__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  int32_t undisturbType;
  NSString *targetId;
  int64_t unreadIndex;
} QryConverResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryConverResp_FieldNumber_TargetId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryConverResp__storage_, targetId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .number = QryConverResp_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryConverResp__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "unreadIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = QryConverResp_FieldNumber_UnreadIndex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(QryConverResp__storage_, unreadIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "undisturbType",
        .dataTypeSpecific.clazz = Nil,
        .number = QryConverResp_FieldNumber_UndisturbType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(QryConverResp__storage_, undisturbType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryConverResp)
                                   messageName:@"QryConverResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryConverResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\004\001\010\000\002\013\000\003\013\000\004\r\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t QryConverResp_ChannelType_RawValue(QryConverResp *message) {
  GPBDescriptor *descriptor = [QryConverResp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryConverResp_FieldNumber_ChannelType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetQryConverResp_ChannelType_RawValue(QryConverResp *message, int32_t value) {
  GPBDescriptor *descriptor = [QryConverResp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryConverResp_FieldNumber_ChannelType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - UserInfo

@implementation UserInfo

@dynamic userId;
@dynamic nickname;
@dynamic userPortrait;
@dynamic extFieldsArray, extFieldsArray_Count;
@dynamic updatedTime;

typedef struct UserInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  NSString *nickname;
  NSString *userPortrait;
  NSMutableArray *extFieldsArray;
  int64_t updatedTime;
} UserInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = UserInfo_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserInfo__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nickname",
        .dataTypeSpecific.clazz = Nil,
        .number = UserInfo_FieldNumber_Nickname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserInfo__storage_, nickname),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userPortrait",
        .dataTypeSpecific.clazz = Nil,
        .number = UserInfo_FieldNumber_UserPortrait,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserInfo__storage_, userPortrait),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extFieldsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(KvItem),
        .number = UserInfo_FieldNumber_ExtFieldsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserInfo__storage_, extFieldsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "updatedTime",
        .dataTypeSpecific.clazz = Nil,
        .number = UserInfo_FieldNumber_UpdatedTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UserInfo__storage_, updatedTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UserInfo)
                                   messageName:@"UserInfo"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\004\001\006\000\003\014\000\004\000extFields\000\005\013\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserIdsReq

@implementation UserIdsReq

@dynamic userIdsArray, userIdsArray_Count;
@dynamic noDispatch;

typedef struct UserIdsReq__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *userIdsArray;
} UserIdsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = UserIdsReq_FieldNumber_UserIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserIdsReq__storage_, userIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "noDispatch",
        .dataTypeSpecific.clazz = Nil,
        .number = UserIdsReq_FieldNumber_NoDispatch,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UserIdsReq)
                                   messageName:@"UserIdsReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserIdsReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\000userIds\000\013\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserIdReq

@implementation UserIdReq

@dynamic userId;

typedef struct UserIdReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
} UserIdReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = UserIdReq_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserIdReq__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UserIdReq)
                                   messageName:@"UserIdReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserIdReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\006\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserInfosResp

@implementation UserInfosResp

@dynamic userInfoMap, userInfoMap_Count;

typedef struct UserInfosResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableDictionary *userInfoMap;
} UserInfosResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userInfoMap",
        .dataTypeSpecific.clazz = GPBObjCClass(UserInfo),
        .number = UserInfosResp_FieldNumber_UserInfoMap,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserInfosResp__storage_, userInfoMap),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UserInfosResp)
                                   messageName:@"UserInfosResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserInfosResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\013\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserRegResp

@implementation UserRegResp

@dynamic userId;
@dynamic token;

typedef struct UserRegResp__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  NSString *token;
} UserRegResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = UserRegResp_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserRegResp__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "token",
        .dataTypeSpecific.clazz = Nil,
        .number = UserRegResp_FieldNumber_Token,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserRegResp__storage_, token),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UserRegResp)
                                   messageName:@"UserRegResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserRegResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\006\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserOnlineStatusReq

@implementation UserOnlineStatusReq

@dynamic userIdsArray, userIdsArray_Count;

typedef struct UserOnlineStatusReq__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *userIdsArray;
} UserOnlineStatusReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = UserOnlineStatusReq_FieldNumber_UserIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserOnlineStatusReq__storage_, userIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UserOnlineStatusReq)
                                   messageName:@"UserOnlineStatusReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserOnlineStatusReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\000userIds\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserOnlineStatusResp

@implementation UserOnlineStatusResp

@dynamic itemsArray, itemsArray_Count;

typedef struct UserOnlineStatusResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemsArray;
} UserOnlineStatusResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UserOnlineItem),
        .number = UserOnlineStatusResp_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserOnlineStatusResp__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UserOnlineStatusResp)
                                   messageName:@"UserOnlineStatusResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserOnlineStatusResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserOnlineItem

@implementation UserOnlineItem

@dynamic userId;
@dynamic isOnline;

typedef struct UserOnlineItem__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
} UserOnlineItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = UserOnlineItem_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserOnlineItem__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isOnline",
        .dataTypeSpecific.clazz = Nil,
        .number = UserOnlineItem_FieldNumber_IsOnline,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(UserOnlineItem)
                                   messageName:@"UserOnlineItem"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserOnlineItem__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\006\000\002\010\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BanUsersReq

@implementation BanUsersReq

@dynamic userIdsArray, userIdsArray_Count;
@dynamic banType;
@dynamic endTime;
@dynamic isAdd;

typedef struct BanUsersReq__storage_ {
  uint32_t _has_storage_[1];
  BanType banType;
  NSMutableArray *userIdsArray;
  int64_t endTime;
} BanUsersReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = BanUsersReq_FieldNumber_UserIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BanUsersReq__storage_, userIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "banType",
        .dataTypeSpecific.enumDescFunc = BanType_EnumDescriptor,
        .number = BanUsersReq_FieldNumber_BanType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BanUsersReq__storage_, banType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.clazz = Nil,
        .number = BanUsersReq_FieldNumber_EndTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BanUsersReq__storage_, endTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isAdd",
        .dataTypeSpecific.clazz = Nil,
        .number = BanUsersReq_FieldNumber_IsAdd,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BanUsersReq)
                                   messageName:@"BanUsersReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BanUsersReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\004\001\000userIds\000\002\007\000\003\007\000\004\005\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t BanUsersReq_BanType_RawValue(BanUsersReq *message) {
  GPBDescriptor *descriptor = [BanUsersReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BanUsersReq_FieldNumber_BanType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetBanUsersReq_BanType_RawValue(BanUsersReq *message, int32_t value) {
  GPBDescriptor *descriptor = [BanUsersReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BanUsersReq_FieldNumber_BanType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - BanUser

@implementation BanUser

@dynamic userId;
@dynamic banType;
@dynamic endTime;
@dynamic createdTime;

typedef struct BanUser__storage_ {
  uint32_t _has_storage_[1];
  BanType banType;
  NSString *userId;
  int64_t endTime;
  int64_t createdTime;
} BanUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = BanUser_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BanUser__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "banType",
        .dataTypeSpecific.enumDescFunc = BanType_EnumDescriptor,
        .number = BanUser_FieldNumber_BanType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BanUser__storage_, banType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.clazz = Nil,
        .number = BanUser_FieldNumber_EndTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BanUser__storage_, endTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "createdTime",
        .dataTypeSpecific.clazz = Nil,
        .number = BanUser_FieldNumber_CreatedTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BanUser__storage_, createdTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BanUser)
                                   messageName:@"BanUser"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BanUser__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\004\001\006\000\002\007\000\003\007\000\004\013\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t BanUser_BanType_RawValue(BanUser *message) {
  GPBDescriptor *descriptor = [BanUser descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BanUser_FieldNumber_BanType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetBanUser_BanType_RawValue(BanUser *message, int32_t value) {
  GPBDescriptor *descriptor = [BanUser descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BanUser_FieldNumber_BanType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryBanUsersReq

@implementation QryBanUsersReq

@dynamic limit;
@dynamic offset;

typedef struct QryBanUsersReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *offset;
  int64_t limit;
} QryBanUsersReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "limit",
        .dataTypeSpecific.clazz = Nil,
        .number = QryBanUsersReq_FieldNumber_Limit,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryBanUsersReq__storage_, limit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "offset",
        .dataTypeSpecific.clazz = Nil,
        .number = QryBanUsersReq_FieldNumber_Offset,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryBanUsersReq__storage_, offset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryBanUsersReq)
                                   messageName:@"QryBanUsersReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryBanUsersReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QryBanUsersResp

@implementation QryBanUsersResp

@dynamic itemsArray, itemsArray_Count;
@dynamic offset;

typedef struct QryBanUsersResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemsArray;
  NSString *offset;
} QryBanUsersResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(BanUser),
        .number = QryBanUsersResp_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QryBanUsersResp__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "offset",
        .dataTypeSpecific.clazz = Nil,
        .number = QryBanUsersResp_FieldNumber_Offset,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryBanUsersResp__storage_, offset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryBanUsersResp)
                                   messageName:@"QryBanUsersResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryBanUsersResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockUsersReq

@implementation BlockUsersReq

@dynamic userIdsArray, userIdsArray_Count;
@dynamic isAdd;

typedef struct BlockUsersReq__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *userIdsArray;
} BlockUsersReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockUsersReq_FieldNumber_UserIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BlockUsersReq__storage_, userIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isAdd",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockUsersReq_FieldNumber_IsAdd,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BlockUsersReq)
                                   messageName:@"BlockUsersReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockUsersReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\000userIds\000\002\005\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QryBlockUsersReq

@implementation QryBlockUsersReq

@dynamic userId;
@dynamic limit;
@dynamic offset;

typedef struct QryBlockUsersReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  NSString *offset;
  int64_t limit;
} QryBlockUsersReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryBlockUsersReq_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryBlockUsersReq__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "limit",
        .dataTypeSpecific.clazz = Nil,
        .number = QryBlockUsersReq_FieldNumber_Limit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryBlockUsersReq__storage_, limit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "offset",
        .dataTypeSpecific.clazz = Nil,
        .number = QryBlockUsersReq_FieldNumber_Offset,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(QryBlockUsersReq__storage_, offset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryBlockUsersReq)
                                   messageName:@"QryBlockUsersReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryBlockUsersReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\006\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockUser

@implementation BlockUser

@dynamic blockUserId;
@dynamic createdTime;

typedef struct BlockUser__storage_ {
  uint32_t _has_storage_[1];
  NSString *blockUserId;
  int64_t createdTime;
} BlockUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blockUserId",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockUser_FieldNumber_BlockUserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockUser__storage_, blockUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createdTime",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockUser_FieldNumber_CreatedTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockUser__storage_, createdTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BlockUser)
                                   messageName:@"BlockUser"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockUser__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\013\000\002\013\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QryBlockUsersResp

@implementation QryBlockUsersResp

@dynamic itemsArray, itemsArray_Count;
@dynamic offset;

typedef struct QryBlockUsersResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemsArray;
  NSString *offset;
} QryBlockUsersResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(BlockUser),
        .number = QryBlockUsersResp_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QryBlockUsersResp__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "offset",
        .dataTypeSpecific.clazz = Nil,
        .number = QryBlockUsersResp_FieldNumber_Offset,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryBlockUsersResp__storage_, offset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryBlockUsersResp)
                                   messageName:@"QryBlockUsersResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryBlockUsersResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OnlineStatus

@implementation OnlineStatus

@dynamic type;
@dynamic extraData;

typedef struct OnlineStatus__storage_ {
  uint32_t _has_storage_[1];
  OnlineType type;
  NSData *extraData;
} OnlineStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = OnlineType_EnumDescriptor,
        .number = OnlineStatus_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OnlineStatus__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "extraData",
        .dataTypeSpecific.clazz = Nil,
        .number = OnlineStatus_FieldNumber_ExtraData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OnlineStatus__storage_, extraData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(OnlineStatus)
                                   messageName:@"OnlineStatus"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OnlineStatus__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\013\t\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t OnlineStatus_Type_RawValue(OnlineStatus *message) {
  GPBDescriptor *descriptor = [OnlineStatus descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:OnlineStatus_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetOnlineStatus_Type_RawValue(OnlineStatus *message, int32_t value) {
  GPBDescriptor *descriptor = [OnlineStatus descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:OnlineStatus_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - KickUserReq

@implementation KickUserReq

@dynamic userId;
@dynamic platformsArray, platformsArray_Count;
@dynamic deviceIdsArray, deviceIdsArray_Count;

typedef struct KickUserReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  NSMutableArray *platformsArray;
  NSMutableArray *deviceIdsArray;
} KickUserReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = KickUserReq_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(KickUserReq__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "platformsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = KickUserReq_FieldNumber_PlatformsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(KickUserReq__storage_, platformsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = KickUserReq_FieldNumber_DeviceIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(KickUserReq__storage_, deviceIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(KickUserReq)
                                   messageName:@"KickUserReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(KickUserReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\006\000\003\000deviceIds\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupInfo

@implementation GroupInfo

@dynamic groupId;
@dynamic groupName;
@dynamic groupPortrait;
@dynamic isMute;
@dynamic extFieldsArray, extFieldsArray_Count;
@dynamic updatedTime;

typedef struct GroupInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t isMute;
  NSString *groupId;
  NSString *groupName;
  NSString *groupPortrait;
  NSMutableArray *extFieldsArray;
  int64_t updatedTime;
} GroupInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupInfo_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupInfo__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupName",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupInfo_FieldNumber_GroupName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupInfo__storage_, groupName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupPortrait",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupInfo_FieldNumber_GroupPortrait,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupInfo__storage_, groupPortrait),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isMute",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupInfo_FieldNumber_IsMute,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GroupInfo__storage_, isMute),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "extFieldsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(KvItem),
        .number = GroupInfo_FieldNumber_ExtFieldsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupInfo__storage_, extFieldsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "updatedTime",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupInfo_FieldNumber_UpdatedTime,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GroupInfo__storage_, updatedTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GroupInfo)
                                   messageName:@"GroupInfo"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\006\001\007\000\002\t\000\003\r\000\004\006\000\005\000extFields\000\006\013\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupMembersReq

@implementation GroupMembersReq

@dynamic groupId;
@dynamic groupName;
@dynamic groupPortrait;
@dynamic memberIdsArray, memberIdsArray_Count;
@dynamic extFieldsArray, extFieldsArray_Count;

typedef struct GroupMembersReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupId;
  NSString *groupName;
  NSString *groupPortrait;
  NSMutableArray *memberIdsArray;
  NSMutableArray *extFieldsArray;
} GroupMembersReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupMembersReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupMembersReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupName",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupMembersReq_FieldNumber_GroupName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupMembersReq__storage_, groupName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupPortrait",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupMembersReq_FieldNumber_GroupPortrait,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupMembersReq__storage_, groupPortrait),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "memberIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupMembersReq_FieldNumber_MemberIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupMembersReq__storage_, memberIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extFieldsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(KvItem),
        .number = GroupMembersReq_FieldNumber_ExtFieldsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupMembersReq__storage_, extFieldsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GroupMembersReq)
                                   messageName:@"GroupMembersReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupMembersReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\005\001\007\000\002\t\000\003\r\000\004\000memberIds\000\005\000extFields\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupMuteReq

@implementation GroupMuteReq

@dynamic groupId;
@dynamic isMute;

typedef struct GroupMuteReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t isMute;
  NSString *groupId;
} GroupMuteReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupMuteReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupMuteReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isMute",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupMuteReq_FieldNumber_IsMute,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupMuteReq__storage_, isMute),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GroupMuteReq)
                                   messageName:@"GroupMuteReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupMuteReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\007\000\002\006\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupInfoReq

@implementation GroupInfoReq

@dynamic groupId;
@dynamic careFieldsArray, careFieldsArray_Count;

typedef struct GroupInfoReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupId;
  NSMutableArray *careFieldsArray;
} GroupInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupInfoReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupInfoReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "careFieldsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupInfoReq_FieldNumber_CareFieldsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupInfoReq__storage_, careFieldsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GroupInfoReq)
                                   messageName:@"GroupInfoReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupInfoReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\007\000\002\000careFields\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupIdsReq

@implementation GroupIdsReq

@dynamic groupIdsArray, groupIdsArray_Count;
@dynamic noDispatch;

typedef struct GroupIdsReq__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *groupIdsArray;
} GroupIdsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupIdsReq_FieldNumber_GroupIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupIdsReq__storage_, groupIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "noDispatch",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupIdsReq_FieldNumber_NoDispatch,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GroupIdsReq)
                                   messageName:@"GroupIdsReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupIdsReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\000groupIds\000\013\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupInfosResp

@implementation GroupInfosResp

@dynamic groupInfoMap, groupInfoMap_Count;

typedef struct GroupInfosResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableDictionary *groupInfoMap;
} GroupInfosResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupInfoMap",
        .dataTypeSpecific.clazz = GPBObjCClass(GroupInfo),
        .number = GroupInfosResp_FieldNumber_GroupInfoMap,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupInfosResp__storage_, groupInfoMap),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GroupInfosResp)
                                   messageName:@"GroupInfosResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupInfosResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\014\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupMemberMuteReq

@implementation GroupMemberMuteReq

@dynamic groupId;
@dynamic memberIdsArray, memberIdsArray_Count;
@dynamic isMute;

typedef struct GroupMemberMuteReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t isMute;
  NSString *groupId;
  NSMutableArray *memberIdsArray;
} GroupMemberMuteReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupMemberMuteReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupMemberMuteReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "memberIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupMemberMuteReq_FieldNumber_MemberIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupMemberMuteReq__storage_, memberIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isMute",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupMemberMuteReq_FieldNumber_IsMute,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupMemberMuteReq__storage_, isMute),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GroupMemberMuteReq)
                                   messageName:@"GroupMemberMuteReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupMemberMuteReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\007\000\002\000memberIds\000\003\006\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupMembersResp

@implementation GroupMembersResp

@dynamic itemsArray, itemsArray_Count;
@dynamic offset;

typedef struct GroupMembersResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemsArray;
  NSString *offset;
} GroupMembersResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GroupMember),
        .number = GroupMembersResp_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupMembersResp__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "offset",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupMembersResp_FieldNumber_Offset,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupMembersResp__storage_, offset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GroupMembersResp)
                                   messageName:@"GroupMembersResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupMembersResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupMember

@implementation GroupMember

@dynamic memberId;
@dynamic isMute;

typedef struct GroupMember__storage_ {
  uint32_t _has_storage_[1];
  int32_t isMute;
  NSString *memberId;
} GroupMember__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "memberId",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupMember_FieldNumber_MemberId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupMember__storage_, memberId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isMute",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupMember_FieldNumber_IsMute,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupMember__storage_, isMute),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GroupMember)
                                   messageName:@"GroupMember"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupMember__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\010\000\002\006\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QryGroupMembersReq

@implementation QryGroupMembersReq

@dynamic groupId;
@dynamic limit;
@dynamic offset;

typedef struct QryGroupMembersReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupId;
  NSString *offset;
  int64_t limit;
} QryGroupMembersReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryGroupMembersReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryGroupMembersReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "limit",
        .dataTypeSpecific.clazz = Nil,
        .number = QryGroupMembersReq_FieldNumber_Limit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryGroupMembersReq__storage_, limit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "offset",
        .dataTypeSpecific.clazz = Nil,
        .number = QryGroupMembersReq_FieldNumber_Offset,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(QryGroupMembersReq__storage_, offset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryGroupMembersReq)
                                   messageName:@"QryGroupMembersReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryGroupMembersReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\007\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckGroupMembersReq

@implementation CheckGroupMembersReq

@dynamic groupId;
@dynamic memberIdsArray, memberIdsArray_Count;

typedef struct CheckGroupMembersReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupId;
  NSMutableArray *memberIdsArray;
} CheckGroupMembersReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = CheckGroupMembersReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CheckGroupMembersReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "memberIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = CheckGroupMembersReq_FieldNumber_MemberIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CheckGroupMembersReq__storage_, memberIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(CheckGroupMembersReq)
                                   messageName:@"CheckGroupMembersReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckGroupMembersReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\007\000\002\000memberIds\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckGroupMembersResp

@implementation CheckGroupMembersResp

@dynamic memberIdMap, memberIdMap_Count;

typedef struct CheckGroupMembersResp__storage_ {
  uint32_t _has_storage_[1];
  GPBStringInt64Dictionary *memberIdMap;
} CheckGroupMembersResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "memberIdMap",
        .dataTypeSpecific.clazz = Nil,
        .number = CheckGroupMembersResp_FieldNumber_MemberIdMap,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CheckGroupMembersResp__storage_, memberIdMap),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(CheckGroupMembersResp)
                                   messageName:@"CheckGroupMembersResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckGroupMembersResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\013\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QryGrpSnapshotReq

@implementation QryGrpSnapshotReq

@dynamic groupId;
@dynamic nearlyTime;

typedef struct QryGrpSnapshotReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupId;
  int64_t nearlyTime;
} QryGrpSnapshotReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = QryGrpSnapshotReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryGrpSnapshotReq__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nearlyTime",
        .dataTypeSpecific.clazz = Nil,
        .number = QryGrpSnapshotReq_FieldNumber_NearlyTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QryGrpSnapshotReq__storage_, nearlyTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryGrpSnapshotReq)
                                   messageName:@"QryGrpSnapshotReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryGrpSnapshotReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\007\000\002\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupSnapshot

@implementation GroupSnapshot

@dynamic groupId;
@dynamic memberIdsArray, memberIdsArray_Count;

typedef struct GroupSnapshot__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupId;
  NSMutableArray *memberIdsArray;
} GroupSnapshot__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupSnapshot_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupSnapshot__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "memberIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GroupSnapshot_FieldNumber_MemberIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupSnapshot__storage_, memberIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GroupSnapshot)
                                   messageName:@"GroupSnapshot"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupSnapshot__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\007\000\002\000memberIds\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SyncChatroomReq

@implementation SyncChatroomReq

@dynamic chatroomId;
@dynamic syncTime;
@dynamic attSyncTime;

typedef struct SyncChatroomReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *chatroomId;
  int64_t syncTime;
  int64_t attSyncTime;
} SyncChatroomReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatroomId",
        .dataTypeSpecific.clazz = Nil,
        .number = SyncChatroomReq_FieldNumber_ChatroomId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SyncChatroomReq__storage_, chatroomId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "syncTime",
        .dataTypeSpecific.clazz = Nil,
        .number = SyncChatroomReq_FieldNumber_SyncTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SyncChatroomReq__storage_, syncTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "attSyncTime",
        .dataTypeSpecific.clazz = Nil,
        .number = SyncChatroomReq_FieldNumber_AttSyncTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SyncChatroomReq__storage_, attSyncTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SyncChatroomReq)
                                   messageName:@"SyncChatroomReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncChatroomReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\n\000\002\010\000\003\013\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SyncChatroomResp

@implementation SyncChatroomResp

@dynamic hasMsgs, msgs;
@dynamic hasAtts, atts;
@dynamic isFinished;

typedef struct SyncChatroomResp__storage_ {
  uint32_t _has_storage_[1];
  DownMsgSet *msgs;
  ChatAtts *atts;
} SyncChatroomResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgs",
        .dataTypeSpecific.clazz = GPBObjCClass(DownMsgSet),
        .number = SyncChatroomResp_FieldNumber_Msgs,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SyncChatroomResp__storage_, msgs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "atts",
        .dataTypeSpecific.clazz = GPBObjCClass(ChatAtts),
        .number = SyncChatroomResp_FieldNumber_Atts,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SyncChatroomResp__storage_, atts),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isFinished",
        .dataTypeSpecific.clazz = Nil,
        .number = SyncChatroomResp_FieldNumber_IsFinished,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SyncChatroomResp)
                                   messageName:@"SyncChatroomResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncChatroomResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\003\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatRoomReq

@implementation ChatRoomReq

@dynamic chatId;

typedef struct ChatRoomReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *chatId;
} ChatRoomReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatId",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatRoomReq_FieldNumber_ChatId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatRoomReq__storage_, chatId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChatRoomReq)
                                   messageName:@"ChatRoomReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatRoomReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\006\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatMembersDispatchReq

@implementation ChatMembersDispatchReq

@dynamic chatId;
@dynamic memberIdsArray, memberIdsArray_Count;
@dynamic dispatchType;

typedef struct ChatMembersDispatchReq__storage_ {
  uint32_t _has_storage_[1];
  ChatMembersDispatchType dispatchType;
  NSString *chatId;
  NSMutableArray *memberIdsArray;
} ChatMembersDispatchReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatId",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatMembersDispatchReq_FieldNumber_ChatId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatMembersDispatchReq__storage_, chatId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "memberIdsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatMembersDispatchReq_FieldNumber_MemberIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChatMembersDispatchReq__storage_, memberIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dispatchType",
        .dataTypeSpecific.enumDescFunc = ChatMembersDispatchType_EnumDescriptor,
        .number = ChatMembersDispatchReq_FieldNumber_DispatchType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatMembersDispatchReq__storage_, dispatchType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChatMembersDispatchReq)
                                   messageName:@"ChatMembersDispatchReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatMembersDispatchReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\006\000\002\000memberIds\000\003\014\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ChatMembersDispatchReq_DispatchType_RawValue(ChatMembersDispatchReq *message) {
  GPBDescriptor *descriptor = [ChatMembersDispatchReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChatMembersDispatchReq_FieldNumber_DispatchType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetChatMembersDispatchReq_DispatchType_RawValue(ChatMembersDispatchReq *message, int32_t value) {
  GPBDescriptor *descriptor = [ChatMembersDispatchReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChatMembersDispatchReq_FieldNumber_DispatchType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - ChatAttReq

@implementation ChatAttReq

@dynamic key;
@dynamic value;
@dynamic isForce;

typedef struct ChatAttReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
  NSString *value;
} ChatAttReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttReq_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatAttReq__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttReq_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatAttReq__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isForce",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttReq_FieldNumber_IsForce,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChatAttReq)
                                   messageName:@"ChatAttReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatAttReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\003\007\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatAttItem

@implementation ChatAttItem

@dynamic key;
@dynamic value;
@dynamic attTime;
@dynamic userId;
@dynamic optType;

typedef struct ChatAttItem__storage_ {
  uint32_t _has_storage_[1];
  ChatAttOptType optType;
  NSString *key;
  NSString *value;
  NSString *userId;
  int64_t attTime;
} ChatAttItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttItem_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatAttItem__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttItem_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatAttItem__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "attTime",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttItem_FieldNumber_AttTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChatAttItem__storage_, attTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAttItem_FieldNumber_UserId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChatAttItem__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "optType",
        .dataTypeSpecific.enumDescFunc = ChatAttOptType_EnumDescriptor,
        .number = ChatAttItem_FieldNumber_OptType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ChatAttItem__storage_, optType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChatAttItem)
                                   messageName:@"ChatAttItem"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatAttItem__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\003\007\000\004\006\000\005\007\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ChatAttItem_OptType_RawValue(ChatAttItem *message) {
  GPBDescriptor *descriptor = [ChatAttItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChatAttItem_FieldNumber_OptType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetChatAttItem_OptType_RawValue(ChatAttItem *message, int32_t value) {
  GPBDescriptor *descriptor = [ChatAttItem descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChatAttItem_FieldNumber_OptType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - ChatAtts

@implementation ChatAtts

@dynamic chatId;
@dynamic attsArray, attsArray_Count;
@dynamic isComplete;
@dynamic isFinished;

typedef struct ChatAtts__storage_ {
  uint32_t _has_storage_[1];
  NSString *chatId;
  NSMutableArray *attsArray;
} ChatAtts__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatId",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAtts_FieldNumber_ChatId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatAtts__storage_, chatId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "attsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(ChatAttItem),
        .number = ChatAtts_FieldNumber_AttsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChatAtts__storage_, attsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isComplete",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAtts_FieldNumber_IsComplete,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isFinished",
        .dataTypeSpecific.clazz = Nil,
        .number = ChatAtts_FieldNumber_IsFinished,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChatAtts)
                                   messageName:@"ChatAtts"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatAtts__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\001\006\000\003\n\000\004\n\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QryFileCredReq

@implementation QryFileCredReq

@dynamic fileType;

typedef struct QryFileCredReq__storage_ {
  uint32_t _has_storage_[1];
  FileType fileType;
} QryFileCredReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fileType",
        .dataTypeSpecific.enumDescFunc = FileType_EnumDescriptor,
        .number = QryFileCredReq_FieldNumber_FileType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryFileCredReq__storage_, fileType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryFileCredReq)
                                   messageName:@"QryFileCredReq"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryFileCredReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\010\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t QryFileCredReq_FileType_RawValue(QryFileCredReq *message) {
  GPBDescriptor *descriptor = [QryFileCredReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryFileCredReq_FieldNumber_FileType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetQryFileCredReq_FileType_RawValue(QryFileCredReq *message, int32_t value) {
  GPBDescriptor *descriptor = [QryFileCredReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryFileCredReq_FieldNumber_FileType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - QryFileCredResp

@implementation QryFileCredResp

@dynamic ossOfOneOfCase;
@dynamic ossType;
@dynamic qiniuCred;

typedef struct QryFileCredResp__storage_ {
  uint32_t _has_storage_[2];
  OssType ossType;
  QiniuCredResp *qiniuCred;
} QryFileCredResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ossType",
        .dataTypeSpecific.enumDescFunc = OssType_EnumDescriptor,
        .number = QryFileCredResp_FieldNumber_OssType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QryFileCredResp__storage_, ossType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "qiniuCred",
        .dataTypeSpecific.clazz = GPBObjCClass(QiniuCredResp),
        .number = QryFileCredResp_FieldNumber_QiniuCred,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(QryFileCredResp__storage_, qiniuCred),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QryFileCredResp)
                                   messageName:@"QryFileCredResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QryFileCredResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    static const char *oneofs[] = {
      "ossOf",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\007\000\013\t\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t QryFileCredResp_OssType_RawValue(QryFileCredResp *message) {
  GPBDescriptor *descriptor = [QryFileCredResp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryFileCredResp_FieldNumber_OssType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetQryFileCredResp_OssType_RawValue(QryFileCredResp *message, int32_t value) {
  GPBDescriptor *descriptor = [QryFileCredResp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:QryFileCredResp_FieldNumber_OssType];
  GPBSetMessageRawEnumField(message, field, value);
}

void QryFileCredResp_ClearOssOfOneOfCase(QryFileCredResp *message) {
  GPBDescriptor *descriptor = [QryFileCredResp descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - QiniuCredResp

@implementation QiniuCredResp

@dynamic domain;
@dynamic token;

typedef struct QiniuCredResp__storage_ {
  uint32_t _has_storage_[1];
  NSString *domain;
  NSString *token;
} QiniuCredResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "domain",
        .dataTypeSpecific.clazz = Nil,
        .number = QiniuCredResp_FieldNumber_Domain,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QiniuCredResp__storage_, domain),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "token",
        .dataTypeSpecific.clazz = Nil,
        .number = QiniuCredResp_FieldNumber_Token,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QiniuCredResp__storage_, token),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(QiniuCredResp)
                                   messageName:@"QiniuCredResp"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QiniuCredResp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OnlineOfflineMsg

@implementation OnlineOfflineMsg

@dynamic type;
@dynamic userId;
@dynamic deviceId;
@dynamic platform;
@dynamic clientIp;
@dynamic sessionId;
@dynamic timestamp;

typedef struct OnlineOfflineMsg__storage_ {
  uint32_t _has_storage_[1];
  OnlineType type;
  NSString *userId;
  NSString *deviceId;
  NSString *platform;
  NSString *clientIp;
  NSString *sessionId;
  int64_t timestamp;
} OnlineOfflineMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = OnlineType_EnumDescriptor,
        .number = OnlineOfflineMsg_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OnlineOfflineMsg__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = OnlineOfflineMsg_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OnlineOfflineMsg__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceId",
        .dataTypeSpecific.clazz = Nil,
        .number = OnlineOfflineMsg_FieldNumber_DeviceId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OnlineOfflineMsg__storage_, deviceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "platform",
        .dataTypeSpecific.clazz = Nil,
        .number = OnlineOfflineMsg_FieldNumber_Platform,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(OnlineOfflineMsg__storage_, platform),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clientIp",
        .dataTypeSpecific.clazz = Nil,
        .number = OnlineOfflineMsg_FieldNumber_ClientIp,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(OnlineOfflineMsg__storage_, clientIp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sessionId",
        .dataTypeSpecific.clazz = Nil,
        .number = OnlineOfflineMsg_FieldNumber_SessionId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(OnlineOfflineMsg__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.clazz = Nil,
        .number = OnlineOfflineMsg_FieldNumber_Timestamp,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(OnlineOfflineMsg__storage_, timestamp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(OnlineOfflineMsg)
                                   messageName:@"OnlineOfflineMsg"
                               fileDescription:&AppmessagesRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OnlineOfflineMsg__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\004\002\006\000\003\010\000\005\010\000\006\t\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t OnlineOfflineMsg_Type_RawValue(OnlineOfflineMsg *message) {
  GPBDescriptor *descriptor = [OnlineOfflineMsg descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:OnlineOfflineMsg_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetOnlineOfflineMsg_Type_RawValue(OnlineOfflineMsg *message, int32_t value) {
  GPBDescriptor *descriptor = [OnlineOfflineMsg descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:OnlineOfflineMsg_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

// clang-format on
